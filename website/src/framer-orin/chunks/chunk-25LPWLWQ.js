// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project dfa04aa1c5bdec07 "Jet - SaaS Template (copy)", do not edit manually */
// /:https://framerusercontent.com/modules/uPkD7RNUO1vmmtMstX6i/UuMuKV94f0TLVC5yiYVK/Dither_Archive.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { ControlType, addPropertyControls, RenderTarget } from "unframer";
import { useEffect, useMemo, useRef } from "react";
import { useInView } from "unframer";
addPropertyControls(Dither, { image: { type: ControlType.ResponsiveImage }, algorithm: { type: ControlType.Enum, title: "Algorithm", options: ["floyd-steinberg", "ordered", "random", "atkinson"], optionTitles: ["Floyd-Steinberg", "Ordered (Bayer)", "Random", "Atkinson"], defaultValue: "floyd-steinberg" }, threshold: { type: ControlType.Number, title: "Threshold", defaultValue: 128, min: 0, max: 255, step: 1 }, brightness: { type: ControlType.Number, title: "Brightness", defaultValue: 0, min: -100, max: 100, step: 1 }, midtones: { type: ControlType.Number, title: "Midtones", defaultValue: 50, min: 0, max: 100, step: 1 }, pixelSize: { type: ControlType.Number, title: "Pixel Size", defaultValue: 1, min: 1, max: 100, step: 1 }, glow: { type: ControlType.Number, title: "Glow", defaultValue: 0, min: 0, max: 50, step: 1 }, backgroundColor: { type: ControlType.Color, title: "Background", defaultValue: "#000000" }, dotColor: { type: ControlType.Color, title: "Pixel Color", defaultValue: "#FFFFFF" }, animation: { type: ControlType.Object, icon: "effect", title: "Animation", controls: { enabled: { type: ControlType.Boolean, title: "Enabled", defaultValue: false }, canvasPreview: { type: ControlType.Boolean, title: "Preview", defaultValue: true, hidden: (props) => !props.enabled }, interval: { type: ControlType.Number, title: "Interval", defaultValue: 0.1, min: 0.01, max: 5, step: 0.01, unit: "s", displayStepper: true, hidden: (props) => !props.enabled }, intensity: { type: ControlType.Number, title: "Intensity", defaultValue: 10, min: 0, max: 100, hidden: (props) => !props.enabled } } }, radius: {
  // @ts-expect-error - BorderRadius is not in this NPM version
  type: ControlType.BorderRadius,
  defaultValue: "0px",
  title: "Radius"
}, enabled: { type: ControlType.Boolean, title: "Enabled", defaultValue: true } });
Dither.defaultProps = { algorithm: "floyd-steinberg", threshold: 128, pixelSize: 1, brightness: 0, glow: 0, midtones: 50, radius: 0, backgroundColor: "#000000", dotColor: "#ffffff", animation: { enabled: false, canvasPreview: true, interval: 0.1, intensity: 10 }, enabled: true };
function Dither(props) {
  const isOnFramerCanvas = RenderTarget.hasRestrictions();
  const hasImage = "image" in props && props.image;
  const canvasRef = useRef(null);
  const isInView = useInView(canvasRef, { once: false });
  const intensityTransformed = useMemo(() => {
    return transformValue(props.animation.intensity, [0, 100], [1e-3, 10]);
  }, [props.animation.intensity]);
  const animationFrameRef = useRef(null);
  const lastTimeRef = useRef(0);
  const elapsedTimeRef = useRef(0);
  const animatedValuesRef = useRef({ brightness: props.brightness, glow: props.glow });
  const handleProcessImage = () => {
    if (!canvasRef.current) return;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    if (!ctx) return;
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      try {
        const aspectRatio = img.naturalWidth / img.naturalHeight;
        const baseResolution = 800;
        let targetWidth, targetHeight;
        if (aspectRatio >= 1) {
          targetWidth = Math.floor(baseResolution / props.pixelSize);
          targetHeight = Math.floor(targetWidth / aspectRatio);
        } else {
          targetHeight = Math.floor(baseResolution / props.pixelSize);
          targetWidth = Math.floor(targetHeight * aspectRatio);
        }
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const brightAdjusted = DitherProcessor.adjustBrightness(imageData, animatedValuesRef.current.brightness);
        const adjustedThreshold = Math.round(props.threshold * props.midtones / 50);
        let processedData;
        switch (props.algorithm) {
          case "floyd-steinberg":
            processedData = DitherProcessor.floydSteinberg(brightAdjusted, adjustedThreshold, props.backgroundColor, props.dotColor);
            break;
          case "ordered":
            processedData = DitherProcessor.ordered(brightAdjusted, adjustedThreshold, props.backgroundColor, props.dotColor);
            break;
          case "random":
            processedData = DitherProcessor.random(brightAdjusted, adjustedThreshold, props.backgroundColor, props.dotColor);
            break;
          case "atkinson":
            processedData = DitherProcessor.atkinson(brightAdjusted, adjustedThreshold, props.backgroundColor, props.dotColor);
            break;
          default:
            processedData = DitherProcessor.floydSteinberg(brightAdjusted, adjustedThreshold, props.backgroundColor, props.dotColor);
        }
        const glowProcessed = DitherProcessor.applyGlow(processedData, animatedValuesRef.current.glow);
        ctx.putImageData(glowProcessed, 0, 0);
      } catch (err) {
        console.error("Failed to process image", err);
      }
    };
    img.src = props.image.src;
  };
  useEffect(() => {
    if (!props.animation.enabled || !isInView) {
      animatedValuesRef.current = { brightness: props.brightness, glow: props.glow };
      handleProcessImage();
      return;
    }
    if (isOnFramerCanvas && !props.animation.canvasPreview) {
      animatedValuesRef.current = { brightness: props.brightness, glow: props.glow };
      handleProcessImage();
      return;
    }
    const generateRandomValue = (baseValue) => {
      const variation = Math.abs(intensityTransformed);
      return baseValue + (Math.random() * 2 - 1) * variation;
    };
    const animate = (currentTime) => {
      if (!lastTimeRef.current) {
        lastTimeRef.current = currentTime;
      }
      const deltaTime = currentTime - lastTimeRef.current;
      elapsedTimeRef.current += deltaTime;
      if (elapsedTimeRef.current >= props.animation.interval * 1e3) {
        const newBrightness = generateRandomValue(props.brightness);
        animatedValuesRef.current = { brightness: newBrightness, glow: props.glow };
        handleProcessImage();
        elapsedTimeRef.current = 0;
      }
      lastTimeRef.current = currentTime;
      animationFrameRef.current = requestAnimationFrame(animate);
    };
    animationFrameRef.current = requestAnimationFrame(animate);
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      lastTimeRef.current = 0;
      elapsedTimeRef.current = 0;
    };
  }, [props.animation.enabled, props.animation.interval, props.animation.intensity, props.animation.canvasPreview, props.brightness, props.glow, props.backgroundColor, props.dotColor, props.algorithm, props.threshold, props.pixelSize, props.midtones, isInView, props.enabled, intensityTransformed]);
  useEffect(() => {
    if (!hasImage) return;
    handleProcessImage();
  }, [props.image, props.algorithm, props.threshold, props.pixelSize, props.midtones, props.backgroundColor, props.dotColor, hasImage, props.enabled]);
  const getAriaLabel = () => {
    if (!props.image.alt) {
      return `Image with ${props.algorithm} dithering applied`;
    }
    return `Dithered version of ${props.image.alt} with ${props.algorithm} dithering applied`;
  };
  if (!hasImage) {
    return /* @__PURE__ */ _jsx("div", { style: { width: "100%", height: "100%", backgroundColor: "#8855FF10", color: "#9966FF", fontFamily: "Inter", fontSize: "11px", letterSpacing: "-0.03em", fontWeight: 400, padding: "40px", display: "flex", justifyContent: "center", alignItems: "center" }, children: "Set up the component by uploading an image." });
  }
  return /* @__PURE__ */ _jsxs("div", { style: { width: "100%", height: "100%", borderRadius: props.radius, overflow: "hidden" }, children: [!props.enabled && /* @__PURE__ */ _jsx("img", { src: props.image.src, alt: props.image.alt, style: { width: "100%", height: "100%", objectFit: "cover" } }), /* @__PURE__ */ _jsx("canvas", { ref: canvasRef, style: { width: "100%", height: "100%", objectFit: "cover", imageRendering: "pixelated", opacity: props.enabled ? 1 : 0 }, "aria-label": getAriaLabel() })] });
}
var DitherProcessor = class {
  // Utility function to convert hex color to RGB
  static hexToRgb(color) {
    color = color.replace(/\s+/g, "");
    const varMatch = color.match(/var\([^,]*,\s*(.*?)\)\s*(?:\/\*|$)/);
    if (varMatch) {
      color = varMatch[1].trim();
    }
    const rgbMatch = color.match(/^rgb\((\d+),(\d+),(\d+)\)$/);
    if (rgbMatch) {
      return { r: parseInt(rgbMatch[1], 10), g: parseInt(rgbMatch[2], 10), b: parseInt(rgbMatch[3], 10) };
    }
    const rgbaMatch = color.match(/^rgba\((\d+),(\d+),(\d+),[\d.]+\)$/);
    if (rgbaMatch) {
      return { r: parseInt(rgbaMatch[1], 10), g: parseInt(rgbaMatch[2], 10), b: parseInt(rgbaMatch[3], 10) };
    }
    const hexMatch = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
    if (hexMatch) {
      return { r: parseInt(hexMatch[1], 16), g: parseInt(hexMatch[2], 16), b: parseInt(hexMatch[3], 16) };
    }
    console.warn("Could not parse color:", color);
    const numbers = color.match(/\d+/g);
    if (numbers && numbers.length >= 3) {
      return { r: parseInt(numbers[0], 10), g: parseInt(numbers[1], 10), b: parseInt(numbers[2], 10) };
    }
    return { r: 0, g: 0, b: 0 };
  }
  // Apply brightness adjustment to image data
  static adjustBrightness(imageData, brightness) {
    const data = new Uint8ClampedArray(imageData.data);
    const factor = 1 + brightness / 100;
    for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.min(255, Math.max(0, Math.round(data[i] * factor)));
      data[i + 1] = Math.min(255, Math.max(0, Math.round(data[i + 1] * factor)));
      data[i + 2] = Math.min(255, Math.max(0, Math.round(data[i + 2] * factor)));
    }
    return new ImageData(data, imageData.width, imageData.height);
  }
  // Apply glow effect to image data
  static applyGlow(imageData, glowAmount) {
    if (glowAmount === 0) return imageData;
    const canvas = document.createElement("canvas");
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    ctx.putImageData(imageData, 0, 0);
    ctx.filter = `blur(${glowAmount / 4}px)`;
    ctx.globalCompositeOperation = "lighter";
    ctx.drawImage(canvas, 0, 0);
    ctx.filter = "none";
    return ctx.getImageData(0, 0, imageData.width, imageData.height);
  }
  // Floyd-Steinberg error diffusion dithering
  static floydSteinberg(imageData, threshold, backgroundColor, dotColor) {
    const data = new Uint8ClampedArray(imageData.data);
    const width = imageData.width;
    const height = imageData.height;
    const bgColor = this.hexToRgb(backgroundColor);
    const dotColorRgb = this.hexToRgb(dotColor);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        const luminance = Math.round(0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2]);
        const useDotColor = luminance > threshold;
        const targetColor = useDotColor ? dotColorRgb : bgColor;
        const errorR = data[idx] - targetColor.r;
        const errorG = data[idx + 1] - targetColor.g;
        const errorB = data[idx + 2] - targetColor.b;
        data[idx] = targetColor.r;
        data[idx + 1] = targetColor.g;
        data[idx + 2] = targetColor.b;
        data[idx + 3] = 255;
        if (x + 1 < width) {
          data[(y * width + (x + 1)) * 4] += errorR * 7 / 16;
          data[(y * width + (x + 1)) * 4 + 1] += errorG * 7 / 16;
          data[(y * width + (x + 1)) * 4 + 2] += errorB * 7 / 16;
        }
        if (y + 1 < height) {
          if (x - 1 >= 0) {
            data[((y + 1) * width + (x - 1)) * 4] += errorR * 3 / 16;
            data[((y + 1) * width + (x - 1)) * 4 + 1] += errorG * 3 / 16;
            data[((y + 1) * width + (x - 1)) * 4 + 2] += errorB * 3 / 16;
          }
          data[((y + 1) * width + x) * 4] += errorR * 5 / 16;
          data[((y + 1) * width + x) * 4 + 1] += errorG * 5 / 16;
          data[((y + 1) * width + x) * 4 + 2] += errorB * 5 / 16;
          if (x + 1 < width) {
            data[((y + 1) * width + (x + 1)) * 4] += errorR / 16;
            data[((y + 1) * width + (x + 1)) * 4 + 1] += errorG / 16;
            data[((y + 1) * width + (x + 1)) * 4 + 2] += errorB / 16;
          }
        }
      }
    }
    return new ImageData(data, width, height);
  }
  // Ordered/Bayer dithering
  static ordered(imageData, threshold, backgroundColor, dotColor) {
    const data = new Uint8ClampedArray(imageData.data);
    const width = imageData.width;
    const height = imageData.height;
    const bgColor = this.hexToRgb(backgroundColor);
    const dotColorRgb = this.hexToRgb(dotColor);
    const bayerMatrix = [[0, 8, 2, 10], [12, 4, 14, 6], [3, 11, 1, 9], [15, 7, 13, 5]];
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        const gray = Math.round(0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2]);
        const bayerValue = bayerMatrix[y % 4][x % 4];
        const adjustedThreshold = threshold + (bayerValue - 7.5) * 16;
        const useDotColor = gray > adjustedThreshold;
        const targetColor = useDotColor ? dotColorRgb : bgColor;
        data[idx] = targetColor.r;
        data[idx + 1] = targetColor.g;
        data[idx + 2] = targetColor.b;
      }
    }
    return new ImageData(data, width, height);
  }
  // Random dithering
  static random(imageData, threshold, backgroundColor, dotColor) {
    const data = new Uint8ClampedArray(imageData.data);
    const width = imageData.width;
    const height = imageData.height;
    const bgColor = this.hexToRgb(backgroundColor);
    const dotColorRgb = this.hexToRgb(dotColor);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        const gray = Math.round(0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2]);
        const randomNoise = (Math.random() - 0.5) * 100;
        const adjustedThreshold = threshold + randomNoise;
        const useDotColor = gray > adjustedThreshold;
        const targetColor = useDotColor ? dotColorRgb : bgColor;
        data[idx] = targetColor.r;
        data[idx + 1] = targetColor.g;
        data[idx + 2] = targetColor.b;
      }
    }
    return new ImageData(data, width, height);
  }
  // Atkinson dithering
  static atkinson(imageData, threshold, backgroundColor, dotColor) {
    const data = new Uint8ClampedArray(imageData.data);
    const width = imageData.width;
    const height = imageData.height;
    const bgColor = this.hexToRgb(backgroundColor);
    const dotColorRgb = this.hexToRgb(dotColor);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        const luminance = Math.round(0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2]);
        const useDotColor = luminance > threshold;
        const targetColor = useDotColor ? dotColorRgb : bgColor;
        const errorR = data[idx] - targetColor.r;
        const errorG = data[idx + 1] - targetColor.g;
        const errorB = data[idx + 2] - targetColor.b;
        data[idx] = targetColor.r;
        data[idx + 1] = targetColor.g;
        data[idx + 2] = targetColor.b;
        data[idx + 3] = 255;
        const positions = [[1, 0], [2, 0], [-1, 1], [0, 1], [1, 1], [0, 2]];
        for (const [dx, dy] of positions) {
          const newX = x + dx;
          const newY = y + dy;
          if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
            const newIdx = (newY * width + newX) * 4;
            data[newIdx] = Math.min(255, Math.max(0, data[newIdx] + errorR / 8));
            data[newIdx + 1] = Math.min(255, Math.max(0, data[newIdx + 1] + errorG / 8));
            data[newIdx + 2] = Math.min(255, Math.max(0, data[newIdx + 2] + errorB / 8));
          }
        }
      }
    }
    return new ImageData(data, width, height);
  }
};
function transformValue(input, inputRange, outputRange, clamp = false) {
  const [inputMin, inputMax] = inputRange;
  const [outputMin, outputMax] = outputRange;
  const progress = (input - inputMin) / (inputMax - inputMin);
  let result = outputMin + progress * (outputMax - outputMin);
  if (clamp) {
    if (outputMax > outputMin) {
      result = Math.min(Math.max(result, outputMin), outputMax);
    } else {
      result = Math.min(Math.max(result, outputMax), outputMin);
    }
  }
  return result;
}
Dither.displayName = "Dither";

export {
  Dither
};
