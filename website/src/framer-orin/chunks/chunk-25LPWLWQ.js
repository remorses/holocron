// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project dfa04aa1c5bdec07 "Jet - SaaS Template (copy)", do not edit manually */
// /:https://framerusercontent.com/modules/uPkD7RNUO1vmmtMstX6i/UuMuKV94f0TLVC5yiYVK/Dither_Archive.js
import { jsx as _jsx, jsxs as _jsxs } from 'react/jsx-runtime'
import { ControlType, addPropertyControls, RenderTarget } from 'unframer'
import { useEffect, useMemo, useRef } from 'react'
import { useInView } from 'unframer'
addPropertyControls(Dither, {
  image: { type: ControlType.ResponsiveImage },
  algorithm: {
    type: ControlType.Enum,
    title: 'Algorithm',
    options: ['floyd-steinberg', 'ordered', 'random', 'atkinson'],
    optionTitles: ['Floyd-Steinberg', 'Ordered (Bayer)', 'Random', 'Atkinson'],
    defaultValue: 'floyd-steinberg',
  },
  threshold: {
    type: ControlType.Number,
    title: 'Threshold',
    defaultValue: 128,
    min: 0,
    max: 255,
    step: 1,
  },
  brightness: {
    type: ControlType.Number,
    title: 'Brightness',
    defaultValue: 0,
    min: -100,
    max: 100,
    step: 1,
  },
  midtones: {
    type: ControlType.Number,
    title: 'Midtones',
    defaultValue: 50,
    min: 0,
    max: 100,
    step: 1,
  },
  pixelSize: {
    type: ControlType.Number,
    title: 'Pixel Size',
    defaultValue: 1,
    min: 1,
    max: 100,
    step: 1,
  },
  glow: {
    type: ControlType.Number,
    title: 'Glow',
    defaultValue: 0,
    min: 0,
    max: 50,
    step: 1,
  },
  backgroundColor: {
    type: ControlType.Color,
    title: 'Background',
    defaultValue: '#000000',
  },
  dotColor: {
    type: ControlType.Color,
    title: 'Pixel Color',
    defaultValue: '#FFFFFF',
  },
  animation: {
    type: ControlType.Object,
    icon: 'effect',
    title: 'Animation',
    controls: {
      enabled: {
        type: ControlType.Boolean,
        title: 'Enabled',
        defaultValue: false,
      },
      canvasPreview: {
        type: ControlType.Boolean,
        title: 'Preview',
        defaultValue: true,
        hidden: (props) => !props.enabled,
      },
      interval: {
        type: ControlType.Number,
        title: 'Interval',
        defaultValue: 0.1,
        min: 0.01,
        max: 5,
        step: 0.01,
        unit: 's',
        displayStepper: true,
        hidden: (props) => !props.enabled,
      },
      intensity: {
        type: ControlType.Number,
        title: 'Intensity',
        defaultValue: 10,
        min: 0,
        max: 100,
        hidden: (props) => !props.enabled,
      },
    },
  },
  radius: {
    // @ts-expect-error - BorderRadius is not in this NPM version
    type: ControlType.BorderRadius,
    defaultValue: '0px',
    title: 'Radius',
  },
  enabled: {
    type: ControlType.Boolean,
    title: 'Enabled',
    defaultValue: true,
  },
})
Dither.defaultProps = {
  algorithm: 'floyd-steinberg',
  threshold: 128,
  pixelSize: 1,
  brightness: 0,
  glow: 0,
  midtones: 50,
  radius: 0,
  backgroundColor: '#000000',
  dotColor: '#ffffff',
  animation: {
    enabled: false,
    canvasPreview: true,
    interval: 0.1,
    intensity: 10,
  },
  enabled: true,
}
function Dither(props) {
  const isOnFramerCanvas = RenderTarget.hasRestrictions()
  const hasImage = 'image' in props && props.image
  const canvasRef = useRef(null)
  const isInView = useInView(canvasRef, { once: false })
  const intensityTransformed = useMemo(() => {
    return transformValue(props.animation.intensity, [0, 100], [1e-3, 10])
  }, [props.animation.intensity])
  const animationFrameRef = useRef(null)
  const lastTimeRef = useRef(0)
  const elapsedTimeRef = useRef(0)
  const animatedValuesRef = useRef({
    brightness: props.brightness,
    glow: props.glow,
  })
  const handleProcessImage = () => {
    if (!canvasRef.current) return
    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d', { willReadFrequently: true })
    if (!ctx) return
    const img = new Image()
    img.crossOrigin = 'anonymous'
    img.onload = () => {
      try {
        const aspectRatio = img.naturalWidth / img.naturalHeight
        const baseResolution = 800
        let targetWidth, targetHeight
        if (aspectRatio >= 1) {
          targetWidth = Math.floor(baseResolution / props.pixelSize)
          targetHeight = Math.floor(targetWidth / aspectRatio)
        } else {
          targetHeight = Math.floor(baseResolution / props.pixelSize)
          targetWidth = Math.floor(targetHeight * aspectRatio)
        }
        canvas.width = targetWidth
        canvas.height = targetHeight
        ctx.imageSmoothingEnabled = false
        ctx.drawImage(img, 0, 0, targetWidth, targetHeight)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
        const brightAdjusted = DitherProcessor.adjustBrightness(
          imageData,
          animatedValuesRef.current.brightness,
        )
        const adjustedThreshold = Math.round(
          (props.threshold * props.midtones) / 50,
        )
        let processedData
        switch (props.algorithm) {
          case 'floyd-steinberg':
            processedData = DitherProcessor.floydSteinberg(
              brightAdjusted,
              adjustedThreshold,
              props.backgroundColor,
              props.dotColor,
            )
            break
          case 'ordered':
            processedData = DitherProcessor.ordered(
              brightAdjusted,
              adjustedThreshold,
              props.backgroundColor,
              props.dotColor,
            )
            break
          case 'random':
            processedData = DitherProcessor.random(
              brightAdjusted,
              adjustedThreshold,
              props.backgroundColor,
              props.dotColor,
            )
            break
          case 'atkinson':
            processedData = DitherProcessor.atkinson(
              brightAdjusted,
              adjustedThreshold,
              props.backgroundColor,
              props.dotColor,
            )
            break
          default:
            processedData = DitherProcessor.floydSteinberg(
              brightAdjusted,
              adjustedThreshold,
              props.backgroundColor,
              props.dotColor,
            )
        }
        const glowProcessed = DitherProcessor.applyGlow(
          processedData,
          animatedValuesRef.current.glow,
        )
        ctx.putImageData(glowProcessed, 0, 0)
      } catch (err) {
        console.error('Failed to process image', err)
      }
    }
    img.src = props.image.src
  }
  useEffect(() => {
    if (!props.animation.enabled || !isInView) {
      animatedValuesRef.current = {
        brightness: props.brightness,
        glow: props.glow,
      }
      handleProcessImage()
      return
    }
    if (isOnFramerCanvas && !props.animation.canvasPreview) {
      animatedValuesRef.current = {
        brightness: props.brightness,
        glow: props.glow,
      }
      handleProcessImage()
      return
    }
    const generateRandomValue = (baseValue) => {
      const variation = Math.abs(intensityTransformed)
      return baseValue + (Math.random() * 2 - 1) * variation
    }
    const animate = (currentTime) => {
      if (!lastTimeRef.current) {
        lastTimeRef.current = currentTime
      }
      const deltaTime = currentTime - lastTimeRef.current
      elapsedTimeRef.current += deltaTime
      if (elapsedTimeRef.current >= props.animation.interval * 1e3) {
        const newBrightness = generateRandomValue(props.brightness)
        animatedValuesRef.current = {
          brightness: newBrightness,
          glow: props.glow,
        }
        handleProcessImage()
        elapsedTimeRef.current = 0
      }
      lastTimeRef.current = currentTime
      animationFrameRef.current = requestAnimationFrame(animate)
    }
    animationFrameRef.current = requestAnimationFrame(animate)
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
      lastTimeRef.current = 0
      elapsedTimeRef.current = 0
    }
  }, [
    props.animation.enabled,
    props.animation.interval,
    props.animation.intensity,
    props.animation.canvasPreview,
    props.brightness,
    props.glow,
    props.backgroundColor,
    props.dotColor,
    props.algorithm,
    props.threshold,
    props.pixelSize,
    props.midtones,
    isInView,
    props.enabled,
    intensityTransformed,
  ])
  useEffect(() => {
    if (!hasImage) return
    handleProcessImage()
  }, [
    props.image,
    props.algorithm,
    props.threshold,
    props.pixelSize,
    props.midtones,
    props.backgroundColor,
    props.dotColor,
    hasImage,
    props.enabled,
  ])
  const getAriaLabel = () => {
    if (!props.image.alt) {
      return `Image with ${props.algorithm} dithering applied`
    }
    return `Dithered version of ${props.image.alt} with ${props.algorithm} dithering applied`
  }
  if (!hasImage) {
    return /* @__PURE__ */ _jsx('div', {
      style: {
        width: '100%',
        height: '100%',
        backgroundColor: '#8855FF10',
        color: '#9966FF',
        fontFamily: 'Inter',
        fontSize: '11px',
        letterSpacing: '-0.03em',
        fontWeight: 400,
        padding: '40px',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
      },
      children: 'Set up the component by uploading an image.',
    })
  }
  return /* @__PURE__ */ _jsxs('div', {
    style: {
      width: '100%',
      height: '100%',
      borderRadius: props.radius,
      overflow: 'hidden',
    },
    children: [
      !props.enabled &&
        /* @__PURE__ */ _jsx('img', {
          src: props.image.src,
          alt: props.image.alt,
          style: {
            width: '100%',
            height: '100%',
            objectFit: 'cover',
          },
        }),
      /* @__PURE__ */ _jsx('canvas', {
        ref: canvasRef,
        style: {
          width: '100%',
          height: '100%',
          objectFit: 'cover',
          imageRendering: 'pixelated',
          opacity: props.enabled ? 1 : 0,
        },
        'aria-label': getAriaLabel(),
      }),
    ],
  })
}
var DitherProcessor = class {
  // Utility function to convert hex color to RGB
  static hexToRgb(color) {
    color = color.replace(/\s+/g, '')
    const varMatch = color.match(/var\([^,]*,\s*(.*?)\)\s*(?:\/\*|$)/)
    if (varMatch) {
      color = varMatch[1].trim()
    }
    const rgbMatch = color.match(/^rgb\((\d+),(\d+),(\d+)\)$/)
    if (rgbMatch) {
      return {
        r: parseInt(rgbMatch[1], 10),
        g: parseInt(rgbMatch[2], 10),
        b: parseInt(rgbMatch[3], 10),
      }
    }
    const rgbaMatch = color.match(/^rgba\((\d+),(\d+),(\d+),[\d.]+\)$/)
    if (rgbaMatch) {
      return {
        r: parseInt(rgbaMatch[1], 10),
        g: parseInt(rgbaMatch[2], 10),
        b: parseInt(rgbaMatch[3], 10),
      }
    }
    const hexMatch = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color)
    if (hexMatch) {
      return {
        r: parseInt(hexMatch[1], 16),
        g: parseInt(hexMatch[2], 16),
        b: parseInt(hexMatch[3], 16),
      }
    }
    console.warn('Could not parse color:', color)
    const numbers = color.match(/\d+/g)
    if (numbers && numbers.length >= 3) {
      return {
        r: parseInt(numbers[0], 10),
        g: parseInt(numbers[1], 10),
        b: parseInt(numbers[2], 10),
      }
    }
    return { r: 0, g: 0, b: 0 }
  }
  // Apply brightness adjustment to image data
  static adjustBrightness(imageData, brightness) {
    const data = new Uint8ClampedArray(imageData.data)
    const factor = 1 + brightness / 100
    for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.min(255, Math.max(0, Math.round(data[i] * factor)))
      data[i + 1] = Math.min(255, Math.max(0, Math.round(data[i + 1] * factor)))
      data[i + 2] = Math.min(255, Math.max(0, Math.round(data[i + 2] * factor)))
    }
    return new ImageData(data, imageData.width, imageData.height)
  }
  // Apply glow effect to image data
  static applyGlow(imageData, glowAmount) {
    if (glowAmount === 0) return imageData
    const canvas = document.createElement('canvas')
    canvas.width = imageData.width
    canvas.height = imageData.height
    const ctx = canvas.getContext('2d', { willReadFrequently: true })
    ctx.putImageData(imageData, 0, 0)
    ctx.filter = `blur(${glowAmount / 4}px)`
    ctx.globalCompositeOperation = 'lighter'
    ctx.drawImage(canvas, 0, 0)
    ctx.filter = 'none'
    return ctx.getImageData(0, 0, imageData.width, imageData.height)
  }
  // Floyd-Steinberg error diffusion dithering
  static floydSteinberg(imageData, threshold, backgroundColor, dotColor) {
    const data = new Uint8ClampedArray(imageData.data)
    const width = imageData.width
    const height = imageData.height
    const bgColor = this.hexToRgb(backgroundColor)
    const dotColorRgb = this.hexToRgb(dotColor)
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4
        const luminance = Math.round(
          0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2],
        )
        const useDotColor = luminance > threshold
        const targetColor = useDotColor ? dotColorRgb : bgColor
        const errorR = data[idx] - targetColor.r
        const errorG = data[idx + 1] - targetColor.g
        const errorB = data[idx + 2] - targetColor.b
        data[idx] = targetColor.r
        data[idx + 1] = targetColor.g
        data[idx + 2] = targetColor.b
        data[idx + 3] = 255
        if (x + 1 < width) {
          data[(y * width + (x + 1)) * 4] += (errorR * 7) / 16
          data[(y * width + (x + 1)) * 4 + 1] += (errorG * 7) / 16
          data[(y * width + (x + 1)) * 4 + 2] += (errorB * 7) / 16
        }
        if (y + 1 < height) {
          if (x - 1 >= 0) {
            data[((y + 1) * width + (x - 1)) * 4] += (errorR * 3) / 16
            data[((y + 1) * width + (x - 1)) * 4 + 1] += (errorG * 3) / 16
            data[((y + 1) * width + (x - 1)) * 4 + 2] += (errorB * 3) / 16
          }
          data[((y + 1) * width + x) * 4] += (errorR * 5) / 16
          data[((y + 1) * width + x) * 4 + 1] += (errorG * 5) / 16
          data[((y + 1) * width + x) * 4 + 2] += (errorB * 5) / 16
          if (x + 1 < width) {
            data[((y + 1) * width + (x + 1)) * 4] += errorR / 16
            data[((y + 1) * width + (x + 1)) * 4 + 1] += errorG / 16
            data[((y + 1) * width + (x + 1)) * 4 + 2] += errorB / 16
          }
        }
      }
    }
    return new ImageData(data, width, height)
  }
  // Ordered/Bayer dithering
  static ordered(imageData, threshold, backgroundColor, dotColor) {
    const data = new Uint8ClampedArray(imageData.data)
    const width = imageData.width
    const height = imageData.height
    const bgColor = this.hexToRgb(backgroundColor)
    const dotColorRgb = this.hexToRgb(dotColor)
    const bayerMatrix = [
      [0, 8, 2, 10],
      [12, 4, 14, 6],
      [3, 11, 1, 9],
      [15, 7, 13, 5],
    ]
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4
        const gray = Math.round(
          0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2],
        )
        const bayerValue = bayerMatrix[y % 4][x % 4]
        const adjustedThreshold = threshold + (bayerValue - 7.5) * 16
        const useDotColor = gray > adjustedThreshold
        const targetColor = useDotColor ? dotColorRgb : bgColor
        data[idx] = targetColor.r
        data[idx + 1] = targetColor.g
        data[idx + 2] = targetColor.b
      }
    }
    return new ImageData(data, width, height)
  }
  // Random dithering
  static random(imageData, threshold, backgroundColor, dotColor) {
    const data = new Uint8ClampedArray(imageData.data)
    const width = imageData.width
    const height = imageData.height
    const bgColor = this.hexToRgb(backgroundColor)
    const dotColorRgb = this.hexToRgb(dotColor)
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4
        const gray = Math.round(
          0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2],
        )
        const randomNoise = (Math.random() - 0.5) * 100
        const adjustedThreshold = threshold + randomNoise
        const useDotColor = gray > adjustedThreshold
        const targetColor = useDotColor ? dotColorRgb : bgColor
        data[idx] = targetColor.r
        data[idx + 1] = targetColor.g
        data[idx + 2] = targetColor.b
      }
    }
    return new ImageData(data, width, height)
  }
  // Atkinson dithering
  static atkinson(imageData, threshold, backgroundColor, dotColor) {
    const data = new Uint8ClampedArray(imageData.data)
    const width = imageData.width
    const height = imageData.height
    const bgColor = this.hexToRgb(backgroundColor)
    const dotColorRgb = this.hexToRgb(dotColor)
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4
        const luminance = Math.round(
          0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2],
        )
        const useDotColor = luminance > threshold
        const targetColor = useDotColor ? dotColorRgb : bgColor
        const errorR = data[idx] - targetColor.r
        const errorG = data[idx + 1] - targetColor.g
        const errorB = data[idx + 2] - targetColor.b
        data[idx] = targetColor.r
        data[idx + 1] = targetColor.g
        data[idx + 2] = targetColor.b
        data[idx + 3] = 255
        const positions = [
          [1, 0],
          [2, 0],
          [-1, 1],
          [0, 1],
          [1, 1],
          [0, 2],
        ]
        for (const [dx, dy] of positions) {
          const newX = x + dx
          const newY = y + dy
          if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
            const newIdx = (newY * width + newX) * 4
            data[newIdx] = Math.min(255, Math.max(0, data[newIdx] + errorR / 8))
            data[newIdx + 1] = Math.min(
              255,
              Math.max(0, data[newIdx + 1] + errorG / 8),
            )
            data[newIdx + 2] = Math.min(
              255,
              Math.max(0, data[newIdx + 2] + errorB / 8),
            )
          }
        }
      }
    }
    return new ImageData(data, width, height)
  }
}
function transformValue(input, inputRange, outputRange, clamp = false) {
  const [inputMin, inputMax] = inputRange
  const [outputMin, outputMax] = outputRange
  const progress = (input - inputMin) / (inputMax - inputMin)
  let result = outputMin + progress * (outputMax - outputMin)
  if (clamp) {
    if (outputMax > outputMin) {
      result = Math.min(Math.max(result, outputMin), outputMax)
    } else {
      result = Math.min(Math.max(result, outputMax), outputMin)
    }
  }
  return result
}
Dither.displayName = 'Dither'

export { Dither }
