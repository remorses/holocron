// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project dfa04aa1c5bdec07 "Jet - SaaS Template (copy)", do not edit manually */
// /:https://framerusercontent.com/modules/XBWSgdKr3syOFOYW80i8/4FKsp3EPd3QDaqVONEJD/DashedBorder.js
import { jsx as _jsx } from 'react/jsx-runtime'
import { useEffect, useRef, useState, useMemo, useCallback } from 'react'
import { addPropertyControls, ControlType, RenderTarget } from 'unframer'
function DashedBorderFrame(props) {
  const defaultProps = useMemo(
    () => ({
      borderColor: '#0099FF',
      borderWidth: 3,
      borderRadius: 16,
      dashLength: 12,
      gapLength: 8,
      animation: { animated: true, speed: 2, direction: 'clockwise' },
      top: true,
      right: true,
      bottom: true,
      left: true,
    }),
    [],
  )
  const {
    borderColor = defaultProps.borderColor,
    borderWidth = defaultProps.borderWidth,
    borderRadius = defaultProps.borderRadius,
    dashLength = defaultProps.dashLength,
    gapLength = defaultProps.gapLength,
    animation = defaultProps.animation,
    style = {},
  } = props
  const { animated, speed, direction } = animation
  const uniqueIdRef = useRef(Math.random().toString(36).substr(2, 9))
  const animName = `dash-anim-${direction}-${uniqueIdRef.current}`
  const minDuration = 0.1
  const animationDuration = `${Math.max(minDuration, 2 / Math.max(0.01, speed))}s`
  const containerRef = useRef(null)
  const resizeObserverRef = useRef(null)
  const [size, setSize] = useState({ width: 400, height: 250 })
  const getCurrentSize = useCallback(() => {
    let w = 200,
      h = 100
    if (!containerRef.current) return { width: w, height: h }
    if (
      RenderTarget.current() === RenderTarget.canvas ||
      RenderTarget.current() === RenderTarget.thumbnail
    ) {
      if (props.style && typeof props.style.width === 'number')
        w = props.style.width
      else w = containerRef.current.offsetWidth
      if (props.style && typeof props.style.height === 'number')
        h = props.style.height
      else h = containerRef.current.offsetHeight
    } else {
      const rect = containerRef.current.getBoundingClientRect()
      w = rect.width
      h = rect.height
    }
    return { width: w, height: h }
  }, [props.style?.width, props.style?.height])
  useEffect(() => {
    if (!containerRef.current) return
    const updateSize = () => {
      const { width: w, height: h } = getCurrentSize()
      setSize((prev) =>
        prev.width !== w || prev.height !== h ? { width: w, height: h } : prev,
      )
    }
    updateSize()
    if (resizeObserverRef.current) {
      resizeObserverRef.current.disconnect()
    }
    resizeObserverRef.current = new window.ResizeObserver(updateSize)
    resizeObserverRef.current.observe(containerRef.current)
    return () => {
      if (resizeObserverRef.current) {
        resizeObserverRef.current.disconnect()
        resizeObserverRef.current = null
      }
    }
  }, [getCurrentSize])
  const width = size.width
  const height = size.height
  const bw = Math.max(1, Math.min(16, borderWidth))
  const normalizedRadius = useMemo(() => {
    if (typeof borderRadius === 'number') return borderRadius
    if (typeof borderRadius === 'string') {
      if (borderRadius.endsWith('px')) return parseFloat(borderRadius)
      if (borderRadius.endsWith('%')) {
        const ratio = parseFloat(borderRadius) / 100
        return Math.max(0, (ratio * Math.min(width, height)) / 2)
      }
      return parseFloat(borderRadius)
    }
    return 0
  }, [borderRadius, width, height])
  const half = bw / 2
  const sides = useMemo(
    () => ({
      top: props.top ?? true,
      right: props.right ?? true,
      bottom: props.bottom ?? true,
      left: props.left ?? true,
    }),
    [props.top, props.right, props.bottom, props.left],
  )
  const perimeter = useMemo(() => {
    const maxR = Math.min(width - bw, height - bw) / 2
    const cr = Math.max(0, Math.min(normalizedRadius, maxR))
    return 2 * (width - bw + height - bw - 4 * cr) + 2 * Math.PI * cr
  }, [width, height, bw, normalizedRadius])
  const patternLength = dashLength + gapLength
  const animOffset = direction === 'clockwise' ? -patternLength : patternLength
  const getBorderPath = useCallback((w, h, bw2, r, sides2) => {
    const half2 = bw2 / 2
    const maxR = Math.min(r, (w - bw2) / 2, (h - bw2) / 2)
    if (!sides2.top && !sides2.right && !sides2.bottom && !sides2.left)
      return ''
    if (sides2.top && sides2.right && sides2.bottom && sides2.left) {
      return [
        `M${half2 + maxR},${half2}`,
        `H${w - half2 - maxR}`,
        `A${maxR},${maxR} 0 0 1 ${w - half2},${half2 + maxR}`,
        `V${h - half2 - maxR}`,
        `A${maxR},${maxR} 0 0 1 ${w - half2 - maxR},${h - half2}`,
        `H${half2 + maxR}`,
        `A${maxR},${maxR} 0 0 1 ${half2},${h - half2 - maxR}`,
        `V${half2 + maxR}`,
        `A${maxR},${maxR} 0 0 1 ${half2 + maxR},${half2}`,
        'Z',
      ].join(' ')
    }
    let d = ''
    if (sides2.top) {
      d += `M${half2 + maxR},${half2} H${w - half2 - maxR} `
      if (sides2.right && maxR > 0) {
        d += `A${maxR},${maxR} 0 0 1 ${w - half2},${half2 + maxR} `
      }
    }
    if (sides2.right) {
      d += `M${w - half2},${half2 + maxR} V${h - half2 - maxR} `
      if (sides2.bottom && maxR > 0) {
        d += `A${maxR},${maxR} 0 0 1 ${w - half2 - maxR},${h - half2} `
      }
    }
    if (sides2.bottom) {
      d += `M${w - half2 - maxR},${h - half2} H${half2 + maxR} `
      if (sides2.left && maxR > 0) {
        d += `A${maxR},${maxR} 0 0 1 ${half2},${h - half2 - maxR} `
      }
    }
    if (sides2.left) {
      d += `M${half2},${h - half2 - maxR} V${half2 + maxR} `
      if (sides2.top && maxR > 0) {
        d += `A${maxR},${maxR} 0 0 1 ${half2 + maxR},${half2} `
      }
    }
    return d.trim()
  }, [])
  const borderPath = useMemo(
    () => getBorderPath(width, height, bw, normalizedRadius, sides),
    [width, height, bw, normalizedRadius, sides, getBorderPath],
  )
  const [animationReady, setAnimationReady] = useState(false)
  useEffect(() => {
    setAnimationReady(false)
    const styleId = `dashed-border-keyframes-${direction}-${uniqueIdRef.current}`
    let styleEl = null
    if (typeof document !== 'undefined') {
      styleEl = document.getElementById(styleId)
      if (!styleEl) {
        styleEl = document.createElement('style')
        styleEl.id = styleId
        document.head.appendChild(styleEl)
      }
      styleEl.innerHTML = `
                @keyframes ${animName} {
                    100% {
                        stroke-dashoffset: ${animOffset};
                    }
                }
            `
      setTimeout(() => setAnimationReady(true), 0)
    }
    return () => {
      if (styleEl && styleEl.parentNode) {
        styleEl.parentNode.removeChild(styleEl)
      }
    }
  }, [direction, animName, animOffset])
  const [visible, setVisible] = useState(false)
  useEffect(() => {
    const loaded =
      props.borderColor !== defaultProps.borderColor ||
      props.borderWidth !== defaultProps.borderWidth ||
      props.borderRadius !== defaultProps.borderRadius ||
      props.dashLength !== defaultProps.dashLength ||
      props.gapLength !== defaultProps.gapLength ||
      (props.animation &&
        (props.animation.animated !== defaultProps.animation.animated ||
          props.animation.speed !== defaultProps.animation.speed ||
          props.animation.direction !== defaultProps.animation.direction)) ||
      props.top !== defaultProps.top ||
      props.right !== defaultProps.right ||
      props.bottom !== defaultProps.bottom ||
      props.left !== defaultProps.left
    if (loaded && !visible) {
      setTimeout(() => setVisible(true), 10)
    }
  }, [
    props.borderColor,
    props.borderWidth,
    props.borderRadius,
    props.dashLength,
    props.gapLength,
    props.animation,
    props.top,
    props.right,
    props.bottom,
    props.left,
    visible,
    defaultProps,
  ])
  return /* @__PURE__ */ _jsx('div', {
    ref: containerRef,
    style: {
      ...style,
      minWidth: 20,
      minHeight: 20,
      width: '100%',
      height: '100%',
      position: 'relative',
      background: 'transparent',
      borderRadius,
      overflow: 'visible',
      pointerEvents: 'none',
      opacity: visible ? 1 : 0,
      transition: visible ? 'opacity 0.4s cubic-bezier(.4,0,.2,1)' : void 0,
    },
    children: /* @__PURE__ */ _jsx('svg', {
      width,
      height,
      viewBox: `0 0 ${width} ${height}`,
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
      },
      'aria-hidden': 'true',
      preserveAspectRatio: 'none',
      children: /* @__PURE__ */ _jsx('path', {
        d: borderPath,
        fill: 'none',
        stroke: borderColor,
        strokeWidth: bw,
        strokeDasharray: `${dashLength},${gapLength}`,
        strokeDashoffset: 0,
        style: {
          animation:
            !animated ||
            RenderTarget.current() === RenderTarget.canvas ||
            RenderTarget.current() === RenderTarget.thumbnail ||
            !animationReady
              ? 'none'
              : `${animName} ${animationDuration} linear infinite`,
        },
      }),
    }),
  })
}
DashedBorderFrame.displayName = 'Animated Dashed Border'
addPropertyControls(DashedBorderFrame, {
  borderColor: {
    type: ControlType.Color,
    title: 'Dash Color',
    defaultValue: '#0099FF',
  },
  borderWidth: {
    type: ControlType.Number,
    title: 'Thickness',
    defaultValue: 3,
    min: 1,
    max: 16,
    step: 1,
    displayStepper: true,
  },
  borderRadius: {
    type: ControlType.Number,
    title: 'Radius',
    defaultValue: 16,
    min: 0,
    max: 200,
    step: 1,
    displayStepper: false,
  },
  dashLength: {
    type: ControlType.Number,
    title: 'Dash',
    defaultValue: 12,
    min: 2,
    max: 40,
    step: 1,
  },
  gapLength: {
    type: ControlType.Number,
    title: 'Gap',
    defaultValue: 8,
    min: 0,
    max: 40,
    step: 1,
  },
  top: {
    type: ControlType.Boolean,
    title: 'Top',
    defaultValue: true,
    enabledTitle: 'Yes',
    disabledTitle: 'No',
  },
  right: {
    type: ControlType.Boolean,
    title: 'Right',
    defaultValue: true,
    enabledTitle: 'Yes',
    disabledTitle: 'No',
  },
  bottom: {
    type: ControlType.Boolean,
    title: 'Bottom',
    defaultValue: true,
    enabledTitle: 'Yes',
    disabledTitle: 'No',
  },
  left: {
    type: ControlType.Boolean,
    title: 'Left',
    defaultValue: true,
    enabledTitle: 'Yes',
    disabledTitle: 'No',
  },
  animation: {
    type: ControlType.Object,
    title: 'Animation',
    controls: {
      animated: {
        type: ControlType.Boolean,
        title: 'Animated',
        defaultValue: true,
        enabledTitle: 'On',
        disabledTitle: 'Off',
      },
      speed: {
        type: ControlType.Number,
        title: 'Speed',
        defaultValue: 2,
        min: 0.1,
        max: 10,
        step: 0.1,
        hidden: (obj) => !obj.animated,
      },
      direction: {
        type: ControlType.Enum,
        title: 'Direction',
        options: ['clockwise', 'counterclockwise'],
        optionTitles: ['Clockwise', 'Counterclockwise'],
        defaultValue: 'clockwise',
        displaySegmentedControl: true,
        segmentedControlDirection: 'vertical',
        hidden: (obj) => !obj.animated,
      },
    },
    defaultValue: { animated: true, speed: 2, direction: 'clockwise' },
  },
})

export { DashedBorderFrame }
