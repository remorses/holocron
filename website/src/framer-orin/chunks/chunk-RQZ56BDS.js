// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project dfa04aa1c5bdec07 "Jet - SaaS Template (copy)", do not edit manually */
// /:https://framerusercontent.com/modules/LZBhe3E2vEwdwNGrGIw7/3TUdBcS7IzAsyVTN4zJh/GodRays_Prod.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { ControlType, addPropertyControls, RenderTarget } from "unframer";
import { useInView } from "unframer";

// /:https://framerusercontent.com/modules/tinL9yUCRdYMMSkYrF00/5r5kMzvOdzXsRZCqA5qG/Bundle.js
import * as e from "react";
import { forwardRef as t, useState as n, useRef as i, useEffect as r, memo as o } from "react";
import { jsx as a } from "react/jsx-runtime";
var __unframerNavigator = typeof window !== "undefined" ? navigator : void 0;
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var s = class {
  constructor(e2, t2, n2, i2, r2 = 0, o2 = 0, a2 = 2, s2 = 8294400) {
    _define_property(this, "parentElement", void 0);
    _define_property(this, "canvasElement", void 0);
    _define_property(this, "gl", void 0);
    _define_property(this, "program", null);
    _define_property(this, "uniformLocations", {});
    _define_property(this, "fragmentShader", void 0);
    _define_property(this, "rafId", null);
    _define_property(this, "lastRenderTime", 0);
    _define_property(this, "totalFrameTime", 0);
    _define_property(this, "speed", 0);
    _define_property(this, "providedUniforms", void 0);
    _define_property(this, "hasBeenDisposed", false);
    _define_property(this, "resolutionChanged", true);
    _define_property(this, "textures", /* @__PURE__ */ new Map());
    _define_property(this, "minPixelRatio", void 0);
    _define_property(this, "maxPixelCount", void 0);
    _define_property(this, "isSafari", function() {
      const e3 = __unframerNavigator.userAgent.toLowerCase();
      return e3.includes("safari") && !e3.includes("chrome") && !e3.includes("android");
    }());
    _define_property(this, "initProgram", () => {
      const e3 = function(e4, t3, n3) {
        const i3 = c(e4, e4.VERTEX_SHADER, t3), r3 = c(e4, e4.FRAGMENT_SHADER, n3);
        if (!i3 || !r3) return null;
        const o3 = e4.createProgram();
        if (!o3) return null;
        if (e4.attachShader(o3, i3), e4.attachShader(o3, r3), e4.linkProgram(o3), !e4.getProgramParameter(o3, e4.LINK_STATUS)) return e4.deleteProgram(o3), e4.deleteShader(i3), e4.deleteShader(r3), null;
        return e4.detachShader(o3, i3), e4.detachShader(o3, r3), e4.deleteShader(i3), e4.deleteShader(r3), o3;
      }(this.gl, l, this.fragmentShader);
      e3 && (this.program = e3);
    });
    _define_property(this, "setupPositionAttribute", () => {
      const e3 = this.gl.getAttribLocation(this.program, "a_position"), t3 = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, t3);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), this.gl.STATIC_DRAW), this.gl.enableVertexAttribArray(e3), this.gl.vertexAttribPointer(e3, 2, this.gl.FLOAT, false, 0, 0);
    });
    _define_property(this, "setupUniforms", () => {
      const e3 = { u_time: this.gl.getUniformLocation(this.program, "u_time"), u_pixelRatio: this.gl.getUniformLocation(this.program, "u_pixelRatio"), u_resolution: this.gl.getUniformLocation(this.program, "u_resolution") };
      Object.entries(this.providedUniforms).forEach(([t3, n3]) => {
        if (e3[t3] = this.gl.getUniformLocation(this.program, t3), n3 instanceof HTMLImageElement) {
          const n4 = `${t3}_aspect_ratio`;
          e3[n4] = this.gl.getUniformLocation(this.program, n4);
        }
      }), this.uniformLocations = e3;
    });
    _define_property(this, "renderScale", 1);
    _define_property(this, "parentWidth", 0);
    _define_property(this, "parentHeight", 0);
    _define_property(this, "resizeObserver", null);
    _define_property(this, "setupResizeObserver", () => {
      this.resizeObserver = new ResizeObserver(([e4]) => {
        e4?.borderBoxSize[0] && (this.parentWidth = e4.borderBoxSize[0].inlineSize, this.parentHeight = e4.borderBoxSize[0].blockSize), this.handleResize();
      }), this.resizeObserver.observe(this.parentElement), visualViewport?.addEventListener("resize", this.handleVisualViewportChange);
      const e3 = this.parentElement.getBoundingClientRect();
      this.parentWidth = e3.width, this.parentHeight = e3.height, this.handleResize();
    });
    _define_property(this, "resizeRafId", null);
    _define_property(this, "handleVisualViewportChange", () => {
      null !== this.resizeRafId && cancelAnimationFrame(this.resizeRafId), this.resizeRafId = requestAnimationFrame(() => {
        this.resizeRafId = requestAnimationFrame(() => {
          this.handleResize();
        });
      });
    });
    _define_property(this, "handleResize", () => {
      null !== this.resizeRafId && cancelAnimationFrame(this.resizeRafId);
      const e3 = visualViewport?.scale ?? 1, t3 = visualViewport ? visualViewport.width * visualViewport.scale : window.innerWidth, n3 = Math.round(1e4 * window.outerWidth / t3) / 1e4, i3 = this.isSafari ? devicePixelRatio : devicePixelRatio / n3, r3 = Math.max(i3, this.minPixelRatio) * n3 * e3, o3 = this.parentWidth * r3, a3 = this.parentHeight * r3, s3 = Math.sqrt(this.maxPixelCount) / Math.sqrt(o3 * a3), l2 = r3 * Math.min(1, s3), c2 = Math.round(this.parentWidth * l2), u2 = Math.round(this.parentHeight * l2);
      this.canvasElement.width === c2 && this.canvasElement.height === u2 && this.renderScale === l2 || (this.renderScale = l2, this.canvasElement.width = c2, this.canvasElement.height = u2, this.resolutionChanged = true, this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.render(performance.now()));
    });
    _define_property(this, "render", (e3) => {
      if (this.hasBeenDisposed) return;
      if (null === this.program) return;
      const t3 = e3 - this.lastRenderTime;
      this.lastRenderTime = e3, 0 !== this.speed && (this.totalFrameTime += t3 * this.speed), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.gl.useProgram(this.program), this.gl.uniform1f(this.uniformLocations.u_time, 1e-3 * this.totalFrameTime), this.resolutionChanged && (this.gl.uniform2f(this.uniformLocations.u_resolution, this.gl.canvas.width, this.gl.canvas.height), this.gl.uniform1f(this.uniformLocations.u_pixelRatio, this.renderScale), this.resolutionChanged = false), this.gl.drawArrays(this.gl.TRIANGLES, 0, 6), 0 !== this.speed ? this.requestRender() : this.rafId = null;
    });
    _define_property(this, "requestRender", () => {
      null !== this.rafId && cancelAnimationFrame(this.rafId), this.rafId = requestAnimationFrame(this.render);
    });
    _define_property(this, "setTextureUniform", (e3, t3) => {
      if (!t3.complete || 0 === t3.naturalWidth) throw new Error(`Paper Shaders: image for uniform ${e3} must be fully loaded`);
      const n3 = this.textures.get(e3);
      n3 && this.gl.deleteTexture(n3);
      const i3 = this.gl.createTexture();
      this.gl.bindTexture(this.gl.TEXTURE_2D, i3), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, t3);
      if (this.gl.getError() !== this.gl.NO_ERROR || null === i3) return;
      this.textures.set(e3, i3);
      const r3 = this.uniformLocations[e3];
      if (r3) {
        const n4 = this.textures.size - 1;
        this.gl.useProgram(this.program), this.gl.activeTexture(this.gl.TEXTURE0 + n4), this.gl.bindTexture(this.gl.TEXTURE_2D, i3), this.gl.uniform1i(r3, n4);
        const o3 = `${e3}_aspect_ratio`, a3 = this.uniformLocations[o3];
        if (a3) {
          const e4 = t3.naturalWidth / t3.naturalHeight;
          this.gl.uniform1f(a3, e4);
        }
      }
    });
    _define_property(this, "setUniformValues", (e3) => {
      this.gl.useProgram(this.program), Object.entries(e3).forEach(([e4, t3]) => {
        const n3 = this.uniformLocations[e4];
        if (n3) if (t3 instanceof HTMLImageElement) this.setTextureUniform(e4, t3);
        else if (Array.isArray(t3)) {
          let e5 = null, i3 = null;
          if (void 0 !== t3[0] && Array.isArray(t3[0])) {
            const n4 = t3[0].length;
            if (!t3.every((e6) => e6.length === n4)) return;
            e5 = t3.flat(), i3 = n4;
          } else e5 = t3, i3 = e5.length;
          switch (i3) {
            case 2:
              this.gl.uniform2fv(n3, e5);
              break;
            case 3:
              this.gl.uniform3fv(n3, e5);
              break;
            case 4:
              this.gl.uniform4fv(n3, e5);
              break;
            case 9:
              this.gl.uniformMatrix3fv(n3, false, e5);
              break;
            case 16:
              this.gl.uniformMatrix4fv(n3, false, e5);
          }
        } else "number" == typeof t3 ? this.gl.uniform1f(n3, t3) : "boolean" == typeof t3 && this.gl.uniform1i(n3, t3 ? 1 : 0);
      });
    });
    _define_property(this, "getCurrentFrameTime", () => this.totalFrameTime);
    _define_property(this, "setFrame", (e3) => {
      this.totalFrameTime = e3, this.lastRenderTime = performance.now(), this.render(performance.now());
    });
    _define_property(this, "setSpeed", (e3 = 1) => {
      this.speed = e3, null === this.rafId && 0 !== e3 && (this.lastRenderTime = performance.now(), this.rafId = requestAnimationFrame(this.render)), null !== this.rafId && 0 === e3 && (cancelAnimationFrame(this.rafId), this.rafId = null);
    });
    _define_property(this, "setUniforms", (e3) => {
      this.providedUniforms = { ...this.providedUniforms, ...e3 }, this.setUniformValues(e3), this.render(performance.now());
    });
    _define_property(this, "dispose", () => {
      this.hasBeenDisposed = true, null !== this.rafId && (cancelAnimationFrame(this.rafId), this.rafId = null), this.gl && this.program && (this.textures.forEach((e3) => {
        this.gl.deleteTexture(e3);
      }), this.textures.clear(), this.gl.deleteProgram(this.program), this.program = null, this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null), this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.gl.getError()), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null), visualViewport?.removeEventListener("resize", this.handleVisualViewportChange), this.uniformLocations = {}, this.parentElement.paperShaderMount = void 0;
    });
    if (!(e2 instanceof HTMLElement)) throw new Error("Paper Shaders: parent element must be an HTMLElement");
    if (this.parentElement = e2, !document.querySelector("style[data-paper-shaders]")) {
      const e3 = document.createElement("style");
      e3.innerHTML = u, e3.setAttribute("data-paper-shaders", ""), document.head.prepend(e3);
    }
    const l1 = document.createElement("canvas");
    this.canvasElement = l1, this.parentElement.prepend(l1), this.fragmentShader = t2, this.providedUniforms = n2, this.totalFrameTime = o2, this.minPixelRatio = a2, this.maxPixelCount = s2;
    const c1 = l1.getContext("webgl2", i2);
    if (!c1) throw new Error("Paper Shaders: WebGL is not supported in this browser");
    this.gl = c1, this.initProgram(), this.setupPositionAttribute(), this.setupUniforms(), this.setUniformValues(this.providedUniforms), this.setupResizeObserver(), this.setSpeed(r2), this.parentElement.setAttribute("data-paper-shaders", ""), this.parentElement.paperShaderMount = this;
  }
};
var l = "#version 300 es\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_objectHelperBox;\n\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxSize;\nout vec2 v_responsiveHelperBox;\nout vec2 v_responsiveBoxGivenSize;\n\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_patternHelperBox;\n\n// #define ADD_HELPERS\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize, vec2 maxBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n  // Sizing api for graphic objects with fixed ratio\n  // (currently supports only ratio = 1)\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize, maxBoxSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_objectHelperBox = uv;\n    v_objectHelperBox *= objectWorldScale;\n    v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);\n  #endif\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.\n  // Full-screen mode available with u_worldWidth = u_worldHeight = 0\n\n  v_responsiveBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize, maxBoxSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_responsiveHelperBox = uv;\n    v_responsiveHelperBox *= responsiveBoxScale;\n    v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for patterns\n  // (treating graphics as a image u_worldWidth x u_worldHeight size)\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize, maxBoxSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_patternHelperBox = uv;\n    v_patternHelperBox *= patternBoxScale;\n    v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);\n  #endif\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  v_patternUV += .5;\n\n  // ===================================================\n\n}";
function c(e2, t2, n2) {
  const i2 = e2.createShader(t2);
  return i2 ? (e2.shaderSource(i2, n2), e2.compileShader(i2), e2.getShaderParameter(i2, e2.COMPILE_STATUS) ? i2 : (e2.deleteShader(i2), null)) : null;
}
var u = "@layer paper-shaders {\n  :where([data-paper-shaders]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n    }\n  }\n}";
var h = { fit: "contain", scale: 1, rotation: 0, offsetX: 0, offsetY: 0, originX: 0.5, originY: 0.5, worldWidth: 0, worldHeight: 0 };
var f = { none: 0, contain: 1, cover: 2 };
var d = 5;
var p = `#version 300 es
precision mediump float;

uniform float u_time;

uniform vec4 u_colorBack;
uniform vec4 u_colors[${d}];
uniform float u_colorsCount;

uniform float u_frequency;
uniform float u_spotty;
uniform float u_midSize;
uniform float u_midIntensity;
uniform float u_density;
uniform float u_blending;


in vec2 v_objectUV;
in vec2 v_responsiveUV;
in vec2 v_responsiveBoxGivenSize;
in vec2 v_patternUV;

out vec4 fragColor;


#define TWO_PI 6.28318530718
#define PI 3.14159265358979323846


float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}


vec2 rotate(vec2 uv, float th) {
  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;
}


float hash(float n) {
  return fract(sin(n * 43758.5453123) * 43758.5453123);
}

float valueNoise(vec2 uv) {
  vec2 i = floor(uv);
  vec2 f = fract(uv);

  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));

  vec2 u = f * f * (3.0 - 2.0 * f);

  float x1 = mix(a, b, u.x);
  float x2 = mix(c, d, u.x);
  return mix(x1, x2, u.y);
}

float raysShape(vec2 uv, float r, float freq, float density, float radius) {
  float a = atan(uv.y, uv.x);
  vec2 left = vec2(a * freq, r);
  vec2 right = vec2(mod(a, TWO_PI) * freq, r);
  float n_left = pow(valueNoise(left), density);
  float n_right = pow(valueNoise(right), density);
  float shape = mix(n_right, n_left, smoothstep(-.15, .15, uv.x));
  return shape;
}

void main() {
  vec2 shape_uv = v_objectUV;

  float t = .2 * u_time;

  float radius = length(shape_uv);
  float spots = 5. * abs(u_spotty);

  float density = 4. - 3. * clamp(u_density, 0., 1.);

  float delta = 1. - smoothstep(0., 1., radius);

  float middleShape = pow(u_midIntensity, .3) * smoothstep(abs(u_midSize), 0.02 * abs(u_midSize), 3.0 * radius);
  middleShape = pow(middleShape, 5.0);

  vec3 accumColor = vec3(0.0);
  float accumAlpha = 0.0;

  for (int i = 0; i < ${d}; i++) {
    if (i >= int(u_colorsCount)) break;

    vec2 rotatedUV = rotate(shape_uv, float(i) + 1.0);

    float r1 = radius * (1.0 + 0.4 * float(i)) - 3.0 * t;
    float r2 = 0.5 * radius * (1.0 + spots) - 2.0 * t;
    float f = mix(1.0, 3.0 + 0.5 * float(i), hash(float(i) + 10.0)) * u_frequency;

    float ray = raysShape(rotatedUV, r1, 5.0 * f, density, radius);
    ray *= raysShape(rotatedUV, r2, 4.0 * f, density, radius);
    ray += (1. + 4. * ray) * middleShape;
    ray = clamp(ray, 0.0, 1.0);

    float srcAlpha = u_colors[i].a * ray;
    vec3 srcColor = u_colors[i].rgb * srcAlpha;

    vec3 alphaBlendColor = accumColor + (1.0 - accumAlpha) * srcColor;
    float alphaBlendAlpha = accumAlpha + (1.0 - accumAlpha) * srcAlpha;

    vec3 addBlendColor = accumColor + srcColor;
    float addBlendAlpha = accumAlpha + srcAlpha;

    accumColor = mix(alphaBlendColor, addBlendColor, u_blending);
    accumAlpha = mix(alphaBlendAlpha, addBlendAlpha, u_blending);
  }

  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;

  vec3 alphaBlendColor = accumColor + (1.0 - accumAlpha) * bgColor;
  float alphaBlendAlpha = accumAlpha + (1.0 - accumAlpha) * u_colorBack.a;

  vec3 addBlendColor = accumColor + bgColor;
  float addBlendAlpha = accumAlpha + u_colorBack.a;

  accumColor = mix(alphaBlendColor, addBlendColor, u_blending);
  accumAlpha = mix(alphaBlendAlpha, addBlendAlpha, u_blending);

  vec3 color = clamp(accumColor, 0.0, 1.0);
  float opacity = clamp(accumAlpha, 0.0, 1.0);


  
  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);


  fragColor = vec4(color, opacity);
}
`;
function m(e2) {
  if (Array.isArray(e2)) return 4 === e2.length ? e2 : 3 === e2.length ? [...e2, 1] : g;
  if ("string" != typeof e2) return g;
  let t2, n2, i2, r2 = 1;
  if (e2.startsWith("#")) [t2, n2, i2, r2] = function(e3) {
    3 === (e3 = e3.replace(/^#/, "")).length && (e3 = e3.split("").map((e4) => e4 + e4).join(""));
    6 === e3.length && (e3 += "ff");
    const t3 = parseInt(e3.slice(0, 2), 16) / 255, n3 = parseInt(e3.slice(2, 4), 16) / 255, i3 = parseInt(e3.slice(4, 6), 16) / 255, r3 = parseInt(e3.slice(6, 8), 16) / 255;
    return [t3, n3, i3, r3];
  }(e2);
  else if (e2.startsWith("rgb")) [t2, n2, i2, r2] = function(e3) {
    const t3 = e3.match(/^rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([0-9.]+))?\s*\)$/i);
    return t3 ? [parseInt(t3[1] ?? "0") / 255, parseInt(t3[2] ?? "0") / 255, parseInt(t3[3] ?? "0") / 255, void 0 === t3[4] ? 1 : parseFloat(t3[4])] : [0, 0, 0, 1];
  }(e2);
  else {
    if (!e2.startsWith("hsl")) return g;
    [t2, n2, i2, r2] = function(e3) {
      const [t3, n3, i3, r3] = e3, o2 = t3 / 360, a2 = n3 / 100, s2 = i3 / 100;
      let l2, c2, u2;
      if (0 === n3) l2 = c2 = u2 = s2;
      else {
        const e4 = (e5, t5, n5) => (n5 < 0 && (n5 += 1), n5 > 1 && (n5 -= 1), n5 < 1 / 6 ? e5 + 6 * (t5 - e5) * n5 : n5 < 0.5 ? t5 : n5 < 2 / 3 ? e5 + (t5 - e5) * (2 / 3 - n5) * 6 : e5), t4 = s2 < 0.5 ? s2 * (1 + a2) : s2 + a2 - s2 * a2, n4 = 2 * s2 - t4;
        l2 = e4(n4, t4, o2 + 1 / 3), c2 = e4(n4, t4, o2), u2 = e4(n4, t4, o2 - 1 / 3);
      }
      return [l2, c2, u2, r3];
    }(function(e3) {
      const t3 = e3.match(/^hsla?\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(?:,\s*([0-9.]+))?\s*\)$/i);
      return t3 ? [parseInt(t3[1] ?? "0"), parseInt(t3[2] ?? "0"), parseInt(t3[3] ?? "0"), void 0 === t3[4] ? 1 : parseFloat(t3[4])] : [0, 0, 0, 1];
    }(e2));
  }
  return [v(t2, 0, 1), v(n2, 0, 1), v(i2, 0, 1), v(r2, 0, 1)];
}
var v = (e2, t2, n2) => Math.min(Math.max(e2, t2), n2);
var g = [0, 0, 0, 1];
function x(t2) {
  const n2 = e.useRef(void 0), i2 = e.useCallback((e2) => {
    const n3 = t2.map((t3) => {
      if (null != t3) {
        if ("function" == typeof t3) {
          const n4 = t3, i3 = n4(e2);
          return "function" == typeof i3 ? i3 : () => {
            n4(null);
          };
        }
        return t3.current = e2, () => {
          t3.current = null;
        };
      }
    });
    return () => {
      n3.forEach((e3) => e3?.());
    };
  }, t2);
  return e.useMemo(() => t2.every((e2) => null == e2) ? null : (e2) => {
    n2.current && (n2.current(), n2.current = void 0), null != e2 && (n2.current = i2(e2));
  }, t2);
}
async function _(e2) {
  const t2 = {}, n2 = [];
  return Object.entries(e2).forEach(([e3, i2]) => {
    if ("string" == typeof i2) {
      if (!((e4) => {
        try {
          return e4.startsWith("/") || new URL(e4), true;
        } catch {
          return false;
        }
      })(i2)) return;
      const r2 = new Promise((n3, r3) => {
        const o2 = new Image();
        ((e4) => {
          try {
            return !e4.startsWith("/") && new URL(e4, window.location.origin).origin !== window.location.origin;
          } catch {
            return false;
          }
        })(i2) && (o2.crossOrigin = "anonymous"), o2.onload = () => {
          t2[e3] = o2, n3();
        }, o2.onerror = () => {
          r3();
        }, o2.src = i2;
      });
      n2.push(r2);
    } else t2[e3] = i2;
  }), await Promise.all(n2), t2;
}
var S = /* @__PURE__ */ t(function({ fragmentShader: e2, uniforms: t2, webGlContextAttributes: o2, speed: l2 = 0, frame: c2 = 0, minPixelRatio: u2, maxPixelCount: h2, ...f2 }, d2) {
  const [p2, m2] = n(false), v2 = i(null), g2 = i(null);
  return r(() => ((async () => {
    const n2 = await _(t2);
    v2.current && !g2.current && (g2.current = new s(v2.current, e2, n2, o2, l2, c2, u2, h2), m2(true));
  })(), () => {
    g2.current?.dispose(), g2.current = null;
  }), [e2, o2]), r(() => {
    (async () => {
      const e3 = await _(t2);
      g2.current?.setUniforms(e3);
    })();
  }, [t2, p2]), r(() => {
    g2.current?.setSpeed(l2);
  }, [l2, p2]), r(() => {
    g2.current?.setFrame(c2);
  }, [c2, p2]), a("div", { ref: x([v2, d2]), ...f2 });
});
S.displayName = "ShaderMount";
var B = { ...h, offsetX: -0.4, offsetY: -0.4, colorBack: "hsla(215, 100%, 11%, 1)", colors: ["hsla(45, 100%, 70%, 1)", "hsla(10, 100%, 80%, 1)", "hsla(178, 100%, 83%, 1)"], frequency: 6, spotty: 0.28, midIntensity: 1, midSize: 3, density: 0.3, blending: 0, speed: 1, frame: 0 };
var b = /* @__PURE__ */ o(function({ speed: e2 = B.speed, frame: t2 = B.frame, colorBack: n2 = B.colorBack, colors: i2 = B.colors, frequency: r2 = B.frequency, spotty: o2 = B.spotty, midIntensity: s2 = B.midIntensity, midSize: l2 = B.midSize, density: c2 = B.density, blending: u2 = B.blending, fit: h2 = B.fit, scale: d2 = B.scale, rotation: v2 = B.rotation, originX: g2 = B.originX, originY: x2 = B.originY, offsetX: _2 = B.offsetX, offsetY: b2 = B.offsetY, worldWidth: R = B.worldWidth, worldHeight: y = B.worldHeight, ...z }) {
  const E = { u_colorBack: m(n2), u_colors: i2.map(m), u_colorsCount: i2.length, u_frequency: r2, u_spotty: o2, u_midIntensity: s2, u_midSize: l2, u_density: c2, u_blending: u2, u_fit: f[h2], u_scale: d2, u_rotation: v2, u_offsetX: _2, u_offsetY: b2, u_originX: g2, u_originY: x2, u_worldWidth: R, u_worldHeight: y };
  return a(S, { ...z, speed: e2, frame: t2, fragmentShader: p, uniforms: E });
}, function(e2, t2) {
  for (const n2 in e2) if ("colors" !== n2) {
    if (false === Object.is(e2[n2], t2[n2])) return false;
  } else {
    const n3 = Array.isArray(e2.colors), i2 = Array.isArray(t2.colors);
    if (!n3 || !i2) {
      if (false === Object.is(e2.colors, t2.colors)) return false;
      continue;
    }
    if (e2.colors?.length !== t2.colors?.length) return false;
    if (!e2.colors?.every((e3, n4) => e3 === t2.colors?.[n4])) return false;
  }
  return true;
});

// /:https://framerusercontent.com/modules/LZBhe3E2vEwdwNGrGIw7/3TUdBcS7IzAsyVTN4zJh/GodRays_Prod.js
import { useRef as useRef2 } from "react";
addPropertyControls(GodRaysComp, { preset: { type: ControlType.Enum, title: "Preset", options: ["Time Travel", "Kinetic Field", "Highway", "Ocean", "Flowers", "Custom"], defaultValue: "Time Travel" }, colorsMode: { type: ControlType.Enum, title: "Color", options: ["Preset", "Custom"], defaultValue: "Preset", displaySegmentedControl: true }, noise: { type: ControlType.Object, optional: true, icon: "effect", controls: { opacity: { type: ControlType.Number, defaultValue: 0.5, min: 0, max: 1, step: 0.01 }, scale: { type: ControlType.Number, defaultValue: 1, min: 0.2, max: 2, step: 0.1 } } }, colorBack: { type: ControlType.Color, title: "Background", defaultValue: "rgb(0,0,0)", hidden: (props) => props.colorsMode === "Preset" }, colors: { type: ControlType.Array, title: "Ray Colors", control: { type: ControlType.Color }, defaultValue: ["rgb(177, 177, 177)"], hidden: (props) => props.colorsMode === "Preset" }, frequency: { type: ControlType.Number, title: "Frequency", defaultValue: 5, min: 0, max: 50, step: 0.5, hidden: (props) => props.preset !== "Custom" }, spotty: { type: ControlType.Number, title: "Spotty", defaultValue: 0.5, min: 0, max: 10, step: 0.1, hidden: (props) => props.preset !== "Custom" }, center: { type: ControlType.Object, title: "Center", controls: { size: { type: ControlType.Number, title: "Size", defaultValue: 0.5, min: 0, max: 1, step: 0.1 }, intensity: { type: ControlType.Number, title: "Intensity", defaultValue: 0.5, min: 0, max: 1, step: 0.01 } }, hidden: (props) => props.preset !== "Custom" }, density: { type: ControlType.Number, title: "Density", defaultValue: 0.5, min: 0, max: 1, step: 0.01, hidden: (props) => props.preset !== "Custom" }, speed: { type: ControlType.Number, title: "Speed", defaultValue: 1, min: 0, max: 10, step: 0.1, hidden: (props) => props.preset !== "Custom" }, offsetX: { type: ControlType.Number, title: "Offset X", defaultValue: 0, min: -2, max: 2, step: 0.01, hidden: (props) => props.preset !== "Custom" }, offsetY: { type: ControlType.Number, title: "Offset Y", defaultValue: 0, min: -2, max: 2, step: 0.01, hidden: (props) => props.preset !== "Custom" }, canvasPreview: { type: ControlType.Boolean, title: "Preview", defaultValue: true, description: "More components at [Framer University](https://frameruni.link/cc)." } });
GodRaysComp.defaultProps = { preset: "Time Travel", colorsMode: "Preset", colorBack: "rgb(0,0,0)", colors: ["rgb(177, 177, 177)"], frequency: 5, spotty: 0.5, center: { size: 0.5, intensity: 0.5 }, density: 0.5, speed: 1, offsetX: 0, offsetY: 0, canvasPreview: true };
function GodRaysComp(props) {
  const isOnFramerCanvas = RenderTarget.hasRestrictions();
  const ref = useRef2(null);
  const isInView = useInView(ref, { once: false });
  const activePreset = props.preset !== "Custom" ? Presets[props.preset] : null;
  const colorBack = props.colorsMode === "Custom" ? parseFramerColor(props.colorBack) : activePreset ? parseFramerColor(activePreset.background) : parseFramerColor(props.colorBack);
  const colors = props.colorsMode === "Custom" ? props.colors.map(parseFramerColor) : activePreset ? activePreset.colors.map(parseFramerColor) : props.colors.map(parseFramerColor);
  const finalSpeed = !props.canvasPreview && isOnFramerCanvas ? 0 : activePreset ? activePreset.speed : props.speed;
  const frequency = activePreset ? activePreset.frequency : props.frequency;
  const spotty = activePreset ? activePreset.spotty : props.spotty;
  const midSize = activePreset ? activePreset.center.size : props.center.size;
  const midIntensity = activePreset ? activePreset.center.intensity : props.center.intensity;
  const density = activePreset ? activePreset.density : props.density;
  const speed = isInView ? finalSpeed : 0;
  const offsetX = activePreset ? activePreset.offsetX : props.offsetX;
  const offsetY = activePreset ? activePreset.offsetY : props.offsetY;
  return /* @__PURE__ */ _jsxs("div", { ref, style: { width: "100%", height: "100%", position: "relative" }, children: [/* @__PURE__ */ _jsx(b, { style: { width: "100%", height: "100%" }, colorBack, colors, frequency, spotty, midSize, midIntensity, density, blending: 1, speed, offsetX, offsetY }), props.noise && props.noise.opacity > 0 && /* @__PURE__ */ _jsx("div", { style: { position: "absolute", inset: 0, backgroundImage: `url("https://framerusercontent.com/images/g0QcWrxr87K0ufOxIUFBakwYA8.png")`, backgroundSize: props.noise.scale * 200, backgroundRepeat: "repeat", opacity: props.noise.opacity / 2 } })] });
}
var Presets = { "Kinetic Field": { background: "rgb(0,0,0)", colors: ["rgb(254, 128, 66)", "rgb(253, 251, 154)", "rgb(123, 76, 70)", "rgb(43, 21, 23)", "rgb(180, 43, 27)"], frequency: 0, spotty: 5, center: { size: 1, intensity: 1 }, density: 0.28, speed: 2, offsetX: 0, offsetY: 0 }, "Time Travel": { background: "rgb(0,0,0)", colors: ["rgb(17, 44, 113)", "rgb(187, 99, 255)", "rgb(86, 225, 233)", "rgb(91, 88, 235)", "rgb(10, 35, 83)"], frequency: 0.5, spotty: 0, center: { size: 0.7, intensity: 0.33 }, density: 0.74, speed: 2, offsetX: 0, offsetY: 0 }, Highway: { background: "rgb(0,0,0)", colors: ["rgb(94, 94, 94)", "rgb(99, 250, 255)", "rgb(0, 229, 255)"], frequency: 2, spotty: 0.2, center: { size: 0, intensity: 0.23 }, density: 0, speed: 1.2, offsetX: 0, offsetY: -1.1 }, Ocean: { background: "rgb(0,0,0)", colors: ["rgb(62, 204, 248)", "rgb(90, 118, 242)", "rgb(41, 84, 231)"], frequency: 1.5, spotty: 0, center: { size: 0.7, intensity: 0.33 }, density: 0.7, speed: 2, offsetX: 0, offsetY: -2 }, Flowers: { background: "rgb(0,0,0)", colors: ["rgb(255, 212, 100)", "rgb(238, 34, 51)", "rgb(95, 134, 250)"], frequency: 0.5, spotty: 1.9, center: { size: 0, intensity: 0.23 }, density: 1, speed: 2, offsetX: -0.55, offsetY: 2 } };
var parseFramerColor = (color) => {
  const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
  const rgbaMatch = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
  if (rgbaMatch) {
    const [_2, r2, g2, b2, a2] = rgbaMatch;
    return `rgba(${r2}, ${g2}, ${b2}, ${a2})`;
  } else if (rgbMatch) {
    const [_2, r2, g2, b2] = rgbMatch;
    return `rgba(${r2}, ${g2}, ${b2}, 1)`;
  }
  console.warn("Could not parse color:", color);
  return "rgba(0, 0, 0, 1)";
};
GodRaysComp.displayName = "God Rays";

// /:https://framerusercontent.com/modules/xx99X8dO7V1Egbc8GwnH/ghH1aHLmGZ0iE7qXDFVk/AnimatedLiquidBackground_Prod.js
import { jsx as _jsx3, jsxs as _jsxs2 } from "react/jsx-runtime";
import { addPropertyControls as addPropertyControls2, ControlType as ControlType2, RenderTarget as RenderTarget3, useIsStaticRenderer } from "unframer";
import { useEffect as useEffect2, useRef as useRef3, useMemo as useMemo3 } from "react";

// /:https://framerusercontent.com/modules/k76epLFsVsF4jlsF5pgg/vhK3G0ntf62fqS2tFDno/useColors.js
import { RenderTarget as RenderTarget2 } from "unframer";
import { useEffect, useState, useMemo as useMemo2 } from "react";
var cssVariableRegex = /var\s*\(\s*(--[\w-]+)(?:\s*,\s*((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*))?\s*\)/;
function useColors(...colors) {
  const isCanvas = RenderTarget2.current() === RenderTarget2.canvas;
  const isOptimizing = typeof window === "undefined";
  const darkMode = useDarkMode();
  const [styleValues, setStyleValues] = useState(() => extractStyleValues(colors.map(extractCSSVariableName)));
  useEffect(() => {
    if (!isCanvas) return;
    const div = document.body.querySelector("main > div");
    if (!div) return;
    const observer = new MutationObserver(() => {
      setStyleValues(extractStyleValues(colors.map(extractCSSVariableName)));
    });
    observer.observe(div, { attributes: true, attributeFilter: ["style"] });
    return () => observer.disconnect();
  }, colors);
  const variableNames = useMemo2(() => colors.map(extractCSSVariableName), [colors]);
  if (isOptimizing) {
    return colors.map((color) => extractDefaultValue(color));
  }
  let values = [];
  for (let i2 = 0; i2 < colors.length; i2++) {
    const color = colors[i2];
    if (typeof color !== "string") {
      values.push(color);
      continue;
    }
    const variableName = variableNames[i2];
    const colorValues = styleValues[variableName];
    if (variableName && colorValues) {
      values.push(darkMode ? colorValues.dark || colorValues.light || color : colorValues.light || color);
    } else {
      values.push(color);
    }
  }
  return values;
}
function extractStyleValues(variableNames) {
  const isCanvas = RenderTarget2.current() === RenderTarget2.canvas;
  const result = {};
  let lightVars = {};
  let darkVars = {};
  if (isCanvas && typeof document !== "undefined") {
    const div = document.body.querySelector("main > div");
    if (div) {
      const style = div.getAttribute("style");
      if (style) {
        const vars = parseVariables(style);
        lightVars = vars;
        darkVars = vars;
      }
    }
  } else {
    const { light, dark } = extractColorStyles();
    lightVars = parseVariables(light);
    darkVars = parseVariables(dark);
  }
  const allVarNames = /* @__PURE__ */ new Set([...Object.keys(lightVars), ...Object.keys(darkVars)]);
  allVarNames.forEach((varName) => {
    result[varName] = { light: lightVars[varName] || "", dark: darkVars[varName] || "" };
  });
  return result;
}
function extractColorStyles() {
  let lightSection = "";
  let darkSection = "";
  if (typeof document !== "undefined") {
    const styles = document.head.querySelectorAll("style[data-framer-css], style[data-framer-css-ssr], style[data-framer-css-ssr-minified]");
    for (const style of styles) {
      const rules = style.sheet?.cssRules;
      if (!rules) continue;
      const styleRules = [];
      for (const rule of rules) {
        if (rule instanceof CSSStyleRule) {
          styleRules.push([rule, false]);
        } else if (rule instanceof CSSMediaRule) {
          if (rule.conditionText === "(prefers-color-scheme: dark)") {
            for (const subrule of rule.cssRules) {
              if (subrule instanceof CSSStyleRule) {
                styleRules.push([subrule, true]);
              }
            }
          }
        }
      }
      for (const [rule, isDarkMedia] of styleRules) {
        const css = rule.cssText;
        const hasVars = css.includes("--token-");
        if (!hasVars) continue;
        const isDark = isDarkMedia ? rule.selectorText === "body" : rule.selectorText === 'body[data-framer-theme="dark"]';
        const isLight = !isDarkMedia && rule.selectorText === "body";
        if (!isDark && !isLight) continue;
        if (isDark) {
          if (!darkSection) {
            darkSection = css.substring(css.indexOf("{") + 1, css.lastIndexOf("}")).trim();
          }
        } else {
          if (!lightSection) {
            lightSection = css.substring(css.indexOf("{") + 1, css.lastIndexOf("}")).trim();
          }
        }
        if (darkSection && lightSection) break;
      }
      if (darkSection && lightSection) break;
    }
  }
  return { light: lightSection, dark: darkSection };
}
function useDarkMode() {
  const isPreview = typeof window !== "undefined" && window.location.origin.endsWith("framercanvas.com");
  const [isDarkMode, setIsDarkMode] = useState(() => {
    if (typeof window === "undefined") {
      return false;
    } else if (isPreview && typeof document !== "undefined") {
      return document.body.getAttribute("data-framer-theme") === "dark";
    } else {
      return window.matchMedia("(prefers-color-scheme: dark)").matches;
    }
  });
  useEffect(() => {
    if (isPreview) {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === "data-framer-theme") {
            const theme = document.body.getAttribute("data-framer-theme");
            setIsDarkMode(theme === "dark");
          }
        });
      });
      observer.observe(document.body, { attributes: true, attributeFilter: ["data-framer-theme"] });
      return () => observer.disconnect();
    } else {
      const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
      const handleChange = (e2) => {
        setIsDarkMode(e2.matches);
      };
      if (mediaQuery.matches !== isDarkMode) {
        setIsDarkMode(mediaQuery.matches);
      }
      mediaQuery.addListener(handleChange);
      return () => mediaQuery.removeListener(handleChange);
    }
  }, [isPreview]);
  return isDarkMode;
}
function extractCSSVariableName(cssString) {
  if (!cssString || !cssString.startsWith("var(")) {
    return "";
  }
  const match = cssVariableRegex.exec(cssString);
  if (match) {
    const variableName = match[1];
    return variableName || "";
  }
  return "";
}
function parseVariables(section) {
  const vars = {};
  if (!section) return vars;
  const declarations = section.split(";").filter(Boolean);
  declarations.forEach((declaration) => {
    const [name, value] = declaration.split(":").map((s2) => s2.trim());
    if (name && value) {
      vars[name] = value;
    }
  });
  return vars;
}
function extractDefaultValue(cssVar) {
  if (!cssVar || !cssVar.startsWith("var(")) {
    return cssVar;
  }
  const content = cssVar.slice(4, -1);
  const parts = content.split(",");
  if (parts.length > 1) {
    return parts.slice(1).join(",").trim();
  }
  return "";
}

// /:https://framer.com/m/index-uMsj.js@PVl4bshKvCOZO36e3vK1
import { jsx as _jsx2 } from "react/jsx-runtime";

// /:https://framerusercontent.com/modules/NLpw4UPElXpirDfZ8gK3/pnnblFdmCm84r7TGjG3U/shader_mount.js
function _define_property2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ShaderMount = class {
  constructor(canvas, fragmentShader, uniforms = {}, webGlContextAttributes, speed = 1, seed = 0) {
    _define_property2(this, "canvas", void 0);
    _define_property2(this, "gl", void 0);
    _define_property2(this, "program", null);
    _define_property2(this, "uniformLocations", {});
    _define_property2(this, "fragmentShader", void 0);
    _define_property2(this, "rafId", null);
    _define_property2(this, "lastFrameTime", 0);
    _define_property2(this, "totalAnimationTime", 0);
    _define_property2(this, "speed", 1);
    _define_property2(this, "providedUniforms", void 0);
    _define_property2(this, "hasBeenDisposed", false);
    _define_property2(this, "resolutionChanged", true);
    _define_property2(this, "initWebGL", () => {
      const program = createProgram(this.gl, vertexShaderSource, this.fragmentShader);
      if (!program) return;
      this.program = program;
      this.setupPositionAttribute();
      this.setupUniforms();
    });
    _define_property2(this, "setupPositionAttribute", () => {
      const positionAttributeLocation = this.gl.getAttribLocation(this.program, "a_position");
      const positionBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
      const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);
      this.gl.enableVertexAttribArray(positionAttributeLocation);
      this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);
    });
    _define_property2(this, "setupUniforms", () => {
      this.uniformLocations = { u_time: this.gl.getUniformLocation(this.program, "u_time"), u_pixelRatio: this.gl.getUniformLocation(this.program, "u_pixelRatio"), u_resolution: this.gl.getUniformLocation(this.program, "u_resolution"), ...Object.fromEntries(Object.keys(this.providedUniforms).map((key) => [key, this.gl.getUniformLocation(this.program, key)])) };
    });
    _define_property2(this, "resizeObserver", null);
    _define_property2(this, "setupResizeObserver", () => {
      this.resizeObserver = new ResizeObserver(() => this.handleResize());
      this.resizeObserver.observe(this.canvas);
      this.handleResize();
    });
    _define_property2(this, "handleResize", () => {
      const pixelRatio = window.devicePixelRatio;
      const newWidth = this.canvas.clientWidth * pixelRatio;
      const newHeight = this.canvas.clientHeight * pixelRatio;
      if (this.canvas.width !== newWidth || this.canvas.height !== newHeight) {
        this.canvas.width = newWidth;
        this.canvas.height = newHeight;
        this.resolutionChanged = true;
        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
        this.render(performance.now());
      }
    });
    _define_property2(this, "render", (currentTime) => {
      if (this.hasBeenDisposed) return;
      const dt = currentTime - this.lastFrameTime;
      this.lastFrameTime = currentTime;
      if (this.speed !== 0) {
        this.totalAnimationTime += dt * this.speed;
      }
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      this.gl.useProgram(this.program);
      this.gl.uniform1f(this.uniformLocations.u_time, this.totalAnimationTime * 1e-3);
      if (this.resolutionChanged) {
        this.gl.uniform2f(this.uniformLocations.u_resolution, this.gl.canvas.width, this.gl.canvas.height);
        this.gl.uniform1f(this.uniformLocations.u_pixelRatio, window.devicePixelRatio);
        this.resolutionChanged = false;
      }
      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
      if (this.speed !== 0) {
        this.requestRender();
      } else {
        this.rafId = null;
      }
    });
    _define_property2(this, "requestRender", () => {
      if (this.rafId !== null) {
        cancelAnimationFrame(this.rafId);
      }
      this.rafId = requestAnimationFrame(this.render);
    });
    _define_property2(this, "updateProvidedUniforms", () => {
      this.gl.useProgram(this.program);
      Object.entries(this.providedUniforms).forEach(([key, value]) => {
        const location = this.uniformLocations[key];
        if (location) {
          if (Array.isArray(value)) {
            switch (value.length) {
              case 2:
                this.gl.uniform2fv(location, value);
                break;
              case 3:
                this.gl.uniform3fv(location, value);
                break;
              case 4:
                this.gl.uniform4fv(location, value);
                break;
              default:
                if (value.length === 9) {
                  this.gl.uniformMatrix3fv(location, false, value);
                } else if (value.length === 16) {
                  this.gl.uniformMatrix4fv(location, false, value);
                } else {
                  console.warn(`Unsupported uniform array length: ${value.length}`);
                }
            }
          } else if (typeof value === "number") {
            this.gl.uniform1f(location, value);
          } else if (typeof value === "boolean") {
            this.gl.uniform1i(location, value ? 1 : 0);
          } else {
            console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);
          }
        }
      });
    });
    _define_property2(this, "setSeed", (newSeed) => {
      const oneFrameAt120Fps = 1e3 / 120;
      this.totalAnimationTime = newSeed * oneFrameAt120Fps;
      this.lastFrameTime = performance.now();
      this.render(performance.now());
    });
    _define_property2(this, "setSpeed", (newSpeed = 1) => {
      this.speed = newSpeed;
      if (this.rafId === null && newSpeed !== 0) {
        this.lastFrameTime = performance.now();
        this.rafId = requestAnimationFrame(this.render);
      }
      if (this.rafId !== null && newSpeed === 0) {
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
      }
    });
    _define_property2(this, "setUniforms", (newUniforms) => {
      this.providedUniforms = { ...this.providedUniforms, ...newUniforms };
      this.updateProvidedUniforms();
      this.render(performance.now());
    });
    _define_property2(this, "dispose", () => {
      this.hasBeenDisposed = true;
      if (this.rafId !== null) {
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
      }
      if (this.gl && this.program) {
        this.gl.deleteProgram(this.program);
        this.program = null;
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.gl.getError();
      }
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
        this.resizeObserver = null;
      }
      this.uniformLocations = {};
    });
    this.canvas = canvas;
    this.fragmentShader = fragmentShader;
    this.providedUniforms = uniforms;
    this.totalAnimationTime = seed;
    const gl = canvas.getContext("webgl2", webGlContextAttributes);
    if (!gl) {
      throw new Error("WebGL not supported");
    }
    this.gl = gl;
    this.initWebGL();
    this.setupResizeObserver();
    this.setSpeed(speed);
    this.canvas.setAttribute("data-paper-shaders", "true");
  }
};
var vertexShaderSource = `#version 300 es
layout(location = 0) in vec4 a_position;

void main() {
  gl_Position = a_position;
}
`;
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  if (!shader) return null;
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}
function createProgram(gl, vertexShaderSource2, fragmentShaderSource) {
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource2);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  if (!vertexShader || !fragmentShader) return null;
  const program = gl.createProgram();
  if (!program) return null;
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Unable to initialize the shader program: " + gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    return null;
  }
  gl.detachShader(program, vertexShader);
  gl.detachShader(program, fragmentShader);
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);
  return program;
}

// /:https://framerusercontent.com/modules/zIDOp1iaNFIXSAIx7ljo/VX06XYWdAlD95B9usTKm/warp.js
var PatternShapes = { Checks: 0, Stripes: 1, Edge: 2 };
var warpFragmentShader = `#version 300 es
precision highp float;

uniform float u_time;
uniform float u_pixelRatio;
uniform vec2 u_resolution;

uniform float u_scale;
uniform float u_rotation;
uniform vec4 u_color1;
uniform vec4 u_color2;
uniform vec4 u_color3;
uniform float u_proportion;
uniform float u_softness;
uniform float u_shape;
uniform float u_shapeScale;
uniform float u_distortion;
uniform float u_swirl;
uniform float u_swirlIterations;


out vec4 fragColor;

#define TWO_PI 6.28318530718
#define PI 3.14159265358979323846

vec2 rotate(vec2 uv, float th) {
  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;
}

float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}
float noise(vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);
  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));

  // Smoothstep for interpolation
  vec2 u = f * f * (3.0 - 2.0 * f);

  // Do the interpolation as two nested mix operations
  // If you try to do this in one big operation, there's enough precision loss to be off by 1px at cell boundaries
  float x1 = mix(a, b, u.x);
  float x2 = mix(c, d, u.x);
  return mix(x1, x2, u.y);

}

vec4 blend_colors(vec4 c1, vec4 c2, vec4 c3, float mixer, float edgesWidth, float edge_blur) {
    vec3 color1 = c1.rgb * c1.a;
    vec3 color2 = c2.rgb * c2.a;
    vec3 color3 = c3.rgb * c3.a;

    float r1 = smoothstep(.0 + .35 * edgesWidth, .7 - .35 * edgesWidth + .5 * edge_blur, mixer);
    float r2 = smoothstep(.3 + .35 * edgesWidth, 1. - .35 * edgesWidth + edge_blur, mixer);

    vec3 blended_color_2 = mix(color1, color2, r1);
    float blended_opacity_2 = mix(c1.a, c2.a, r1);

    vec3 c = mix(blended_color_2, color3, r2);
    float o = mix(blended_opacity_2, c3.a, r2);
    return vec4(c, o);
}

void main() {
    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
    vec2 uv_original = uv;

    float t = .5 * u_time;

    float noise_scale = .0005 + .006 * u_scale;

    uv -= .5;
    uv *= (noise_scale * u_resolution);
    uv = rotate(uv, u_rotation * .5 * PI);
    uv /= u_pixelRatio;
    uv += .5;

    float n1 = noise(uv * 1. + t);
    float n2 = noise(uv * 2. - t);
    float angle = n1 * TWO_PI;
    uv.x += 4. * u_distortion * n2 * cos(angle);
    uv.y += 4. * u_distortion * n2 * sin(angle);

    float iterations_number = ceil(clamp(u_swirlIterations, 1., 30.));
    for (float i = 1.; i <= iterations_number; i++) {
        uv.x += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1.5 * uv.y);
        uv.y += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1. * uv.x);
    }

    float proportion = clamp(u_proportion, 0., 1.);

    float shape = 0.;
    float mixer = 0.;
    if (u_shape < .5) {
      vec2 checks_shape_uv = uv * (.5 + 3.5 * u_shapeScale);
      shape = .5 + .5 * sin(checks_shape_uv.x) * cos(checks_shape_uv.y);
      mixer = shape + .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);
    } else if (u_shape < 1.5) {
      vec2 stripes_shape_uv = uv * (.25 + 3. * u_shapeScale);
      float f = fract(stripes_shape_uv.y);
      shape = smoothstep(.0, .55, f) * smoothstep(1., .45, f);
      mixer = shape + .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);
    } else {
      float sh = 1. - uv.y;
      sh -= .5;
      sh /= (noise_scale * u_resolution.y);
      sh += .5;
      float shape_scaling = .2 * (1. - u_shapeScale);
      shape = smoothstep(.45 - shape_scaling, .55 + shape_scaling, sh + .3 * (proportion - .5));
      mixer = shape;
    }

    vec4 color_mix = blend_colors(u_color1, u_color2, u_color3, mixer, 1. - clamp(u_softness, 0., 1.), .01 + .01 * u_scale);

    fragColor = vec4(color_mix.rgb, color_mix.a);
}
`;

// /:https://framerusercontent.com/modules/r591zLdRh7n2CKaaHRG7/PCYxubr6wk68eTxKLhEH/get_shader_color_from_string.js
function getShaderColorFromString(colorString, fallback = [0, 0, 0, 1]) {
  if (Array.isArray(colorString)) {
    if (colorString.length === 4) return colorString;
    if (colorString.length === 3) return [...colorString, 1];
    return getShaderColorFromString(fallback);
  }
  if (typeof colorString !== "string") {
    return getShaderColorFromString(fallback);
  }
  let r2, g2, b2, a2 = 1;
  if (colorString.startsWith("#")) {
    [r2, g2, b2, a2] = hexToRgba(colorString);
  } else if (colorString.startsWith("rgb")) {
    [r2, g2, b2, a2] = parseRgba(colorString);
  } else if (colorString.startsWith("hsl")) {
    [r2, g2, b2, a2] = hslaToRgba(parseHsla(colorString));
  } else {
    console.error("Unsupported color format", colorString);
    return getShaderColorFromString(fallback);
  }
  return [clamp(r2, 0, 1), clamp(g2, 0, 1), clamp(b2, 0, 1), clamp(a2, 0, 1)];
}
function hexToRgba(hex) {
  hex = hex.replace(/^#/, "");
  if (hex.length === 3) {
    hex = hex.split("").map((char) => char + char).join("");
  }
  if (hex.length === 6) {
    hex = hex + "ff";
  }
  const r2 = parseInt(hex.slice(0, 2), 16) / 255;
  const g2 = parseInt(hex.slice(2, 4), 16) / 255;
  const b2 = parseInt(hex.slice(4, 6), 16) / 255;
  const a2 = parseInt(hex.slice(6, 8), 16) / 255;
  return [r2, g2, b2, a2];
}
function parseRgba(rgba) {
  const match = rgba.match(/^rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([0-9.]+))?\s*\)$/i);
  if (!match) return [0, 0, 0, 1];
  return [parseInt(match[1] ?? "0") / 255, parseInt(match[2] ?? "0") / 255, parseInt(match[3] ?? "0") / 255, match[4] === void 0 ? 1 : parseFloat(match[4])];
}
function parseHsla(hsla) {
  const match = hsla.match(/^hsla?\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(?:,\s*([0-9.]+))?\s*\)$/i);
  if (!match) return [0, 0, 0, 1];
  return [parseInt(match[1] ?? "0"), parseInt(match[2] ?? "0"), parseInt(match[3] ?? "0"), match[4] === void 0 ? 1 : parseFloat(match[4])];
}
function hslaToRgba(hsla) {
  const [h2, s2, l2, a2] = hsla;
  const hDecimal = h2 / 360;
  const sDecimal = s2 / 100;
  const lDecimal = l2 / 100;
  let r2, g2, b2;
  if (s2 === 0) {
    r2 = g2 = b2 = lDecimal;
  } else {
    const hue2rgb = (p22, q2, t2) => {
      if (t2 < 0) t2 += 1;
      if (t2 > 1) t2 -= 1;
      if (t2 < 1 / 6) return p22 + (q2 - p22) * 6 * t2;
      if (t2 < 1 / 2) return q2;
      if (t2 < 2 / 3) return p22 + (q2 - p22) * (2 / 3 - t2) * 6;
      return p22;
    };
    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;
    const p2 = 2 * lDecimal - q;
    r2 = hue2rgb(p2, q, hDecimal + 1 / 3);
    g2 = hue2rgb(p2, q, hDecimal);
    b2 = hue2rgb(p2, q, hDecimal - 1 / 3);
  }
  return [r2, g2, b2, a2];
}
var clamp = (n2, min, max) => Math.min(Math.max(n2, min), max);

// /:https://framerusercontent.com/modules/xx99X8dO7V1Egbc8GwnH/ghH1aHLmGZ0iE7qXDFVk/AnimatedLiquidBackground_Prod.js
import { cubicBezier, useInView as useInView2 } from "unframer";
var speedEase = cubicBezier(0.65, 0, 0.88, 0.77);
var templates = { Prism: { color1: "#050505", color2: "#66B3FF", color3: "#FFFFFF", rotation: -50, proportion: 1, scale: 0.01, speed: 30, distortion: 0, swirl: 50, swirlIterations: 16, softness: 47, offset: -299, shape: "Checks", shapeSize: 45 }, Lava: { color1: "#FF9F21", color2: "#FF0303", color3: "#000000", rotation: 114, proportion: 100, scale: 0.52, speed: 30, distortion: 7, swirl: 18, swirlIterations: 20, softness: 100, offset: 717, shape: "Edge", shapeSize: 12 }, Plasma: { color1: "#B566FF", color2: "#000000", color3: "#000000", rotation: 0, proportion: 63, scale: 0.75, speed: 30, distortion: 5, swirl: 61, swirlIterations: 5, softness: 100, offset: -168, shape: "Checks", shapeSize: 28 }, Pulse: { color1: "#66FF85", color2: "#000000", color3: "#000000", rotation: -167, proportion: 92, scale: 0, speed: 20, distortion: 54, swirl: 75, swirlIterations: 3, softness: 28, offset: -813, shape: "Checks", shapeSize: 79 }, Vortex: { color1: "#000000", color2: "#FFFFFF", color3: "#000000", rotation: 50, proportion: 41, scale: 0.4, speed: 20, distortion: 0, swirl: 100, swirlIterations: 3, softness: 5, offset: -744, shape: "Stripes", shapeSize: 80 }, Mist: { color1: "#050505", color2: "#FF66B8", color3: "#050505", rotation: 0, proportion: 33, scale: 0.48, speed: 39, distortion: 4, swirl: 65, swirlIterations: 5, softness: 100, offset: -235, shape: "Edge", shapeSize: 48 } };
function AnimatedGradientBackground(props) {
  const isStaticRenderer = useIsStaticRenderer();
  const isCanvas = RenderTarget3.current() === RenderTarget3.canvas;
  const useCustomColors = props.preset === "custom" || props.colorMode === "custom";
  const values = props.preset === "custom" ? props : templates[props.preset] || Object.values(templates)[0];
  const [color1, color2, color3] = useColors(props.color1, props.color2, props.color3);
  const ref = useRef3(null);
  const isInView = useInView2(ref, { once: false, amount: 0.1 });
  const currentSpeed = useMemo3(() => {
    if (isCanvas && props.preview) return speedEase(props.speed / 100) * 5;
    if (!isStaticRenderer && isInView) return speedEase(props.speed / 100) * 5;
    return 0;
  }, [isInView, isStaticRenderer, props.speed, props.preview, isCanvas]);
  return /* @__PURE__ */ _jsxs2("div", { ref, style: { borderRadius: props.radius, overflow: "hidden", position: "relative", ...props.style }, children: [/* @__PURE__ */ _jsx3(Warp, { color1: useCustomColors ? color1 : values.color1, color2: useCustomColors ? color2 : values.color2, color3: useCustomColors ? color3 : values.color3, scale: values.scale, proportion: values.proportion / 100, distortion: values.distortion / 50, swirl: values.swirl / 100, swirlIterations: values.swirl === 0 ? 0 : values.swirlIterations, rotation: values.rotation * Math.PI / 180, speed: currentSpeed, seed: values.offset * 10, shape: PatternShapes[values.shape], shapeScale: values.shapeSize / 100, softness: values.softness / 100, style: props.style }), props.noise && props.noise.opacity > 0 && /* @__PURE__ */ _jsx3("div", { style: { position: "absolute", inset: 0, backgroundImage: `url("https://framerusercontent.com/images/g0QcWrxr87K0ufOxIUFBakwYA8.png")`, backgroundSize: props.noise.scale * 200, backgroundRepeat: "repeat", opacity: props.noise.opacity / 2 } })] });
}
addPropertyControls2(AnimatedGradientBackground, { preset: { type: ControlType2.Enum, defaultValue: Object.keys(templates)[0], options: [...Object.keys(templates), "custom"], optionTitles: [...Object.keys(templates), "Custom"] }, preview: { type: ControlType2.Boolean, defaultValue: false }, colorMode: { type: ControlType2.Enum, defaultValue: "preset", options: ["preset", "custom"], optionTitles: ["Preset", "Custom"], displaySegmentedControl: true, title: "Colors", hidden: (props) => props.preset === "custom" }, color1: { type: ControlType2.Color, defaultValue: "#262626", hidden: (props) => props.preset !== "custom" && props.colorMode === "preset" }, color2: { type: ControlType2.Color, defaultValue: "#75c1f0", hidden: (props) => props.preset !== "custom" && props.colorMode === "preset" }, color3: { type: ControlType2.Color, defaultValue: "#ffffff", hidden: (props) => props.preset !== "custom" && props.colorMode === "preset" }, noise: { type: ControlType2.Object, optional: true, icon: "effect", controls: { opacity: { type: ControlType2.Number, defaultValue: 0.5, min: 0, max: 1, step: 0.01 }, scale: { type: ControlType2.Number, defaultValue: 1, min: 0.2, max: 2, step: 0.1 } } }, rotation: { type: ControlType2.Number, defaultValue: 0, min: -360, max: 360, step: 1, unit: "\xB0", hidden: (props) => props.preset !== "custom" }, proportion: { type: ControlType2.Number, defaultValue: 35, min: 0, max: 100, step: 1, hidden: (props) => props.preset !== "custom" }, scale: { type: ControlType2.Number, defaultValue: 1, min: 0, max: 10, step: 0.01, hidden: (props) => props.preset !== "custom" }, speed: { type: ControlType2.Number, defaultValue: 25, step: 1, min: 0, max: 100 }, distortion: { type: ControlType2.Number, defaultValue: 12, min: 0, max: 100, step: 1, hidden: (props) => props.preset !== "custom" }, swirl: { type: ControlType2.Number, defaultValue: 80, min: 0, max: 100, step: 1, hidden: (props) => props.preset !== "custom" }, swirlIterations: { type: ControlType2.Number, defaultValue: 10, min: 0, max: 20, step: 1, title: "Iterations", hidden: (props) => props.swirl === 0 || props.preset !== "custom" }, softness: { type: ControlType2.Number, defaultValue: 100, min: 0, max: 100, step: 1, hidden: (props) => props.preset !== "custom" }, offset: { type: ControlType2.Number, defaultValue: 0, min: -1e3, max: 1e3, step: 1, hidden: (props) => props.preset !== "custom" }, shape: { type: ControlType2.Enum, defaultValue: "Checks", options: Object.keys(PatternShapes), hidden: (props) => props.preset !== "custom" }, shapeSize: { type: ControlType2.Number, defaultValue: 10, min: 0, max: 100, step: 1, hidden: (props) => props.preset !== "custom" }, radius: { type: ControlType2.BorderRadius, defaultValue: "0px" } });
var defaultPreset = { name: "Default", params: { scale: 1, rotation: 0, speed: 20, seed: 0, color1: "hsla(0, 0%, 15%, 1)", color2: "hsla(203, 80%, 70%, 1)", color3: "hsla(0, 0%, 100%, 1)", proportion: 0.35, softness: 1, distortion: 0.25, swirl: 0.8, swirlIterations: 10, shapeScale: 0.1, shape: PatternShapes.Checks } };
var Warp = (props) => {
  const uniforms = useMemo3(() => {
    return { u_scale: props.scale ?? defaultPreset.params.scale, u_rotation: props.rotation ?? defaultPreset.params.rotation, u_color1: getShaderColorFromString(props.color1, defaultPreset.params.color1), u_color2: getShaderColorFromString(props.color2, defaultPreset.params.color2), u_color3: getShaderColorFromString(props.color3, defaultPreset.params.color2), u_proportion: props.proportion ?? defaultPreset.params.proportion, u_softness: props.softness ?? defaultPreset.params.softness, u_distortion: props.distortion ?? defaultPreset.params.distortion, u_swirl: props.swirl ?? defaultPreset.params.swirl, u_swirlIterations: props.swirlIterations ?? defaultPreset.params.swirlIterations, u_shapeScale: props.shapeScale ?? defaultPreset.params.shapeScale, u_shape: props.shape ?? defaultPreset.params.shape };
  }, [props.scale, props.rotation, props.color1, props.color2, props.color3, props.proportion, props.softness, props.distortion, props.swirl, props.swirlIterations, props.shapeScale, props.shape, props.speed]);
  return /* @__PURE__ */ _jsx3(ShaderMount2, { ...props, fragmentShader: warpFragmentShader, uniforms });
};
var ShaderMount2 = ({ ref, fragmentShader, style, uniforms = {}, webGlContextAttributes, speed = 1, seed = 0 }) => {
  const canvasRef = ref ?? useRef3(null);
  const shaderMountRef = useRef3(null);
  useEffect2(() => {
    if (canvasRef.current) {
      shaderMountRef.current = new ShaderMount(canvasRef.current, fragmentShader, uniforms, webGlContextAttributes, speed, seed);
    }
    return () => {
      shaderMountRef.current?.dispose();
    };
  }, [fragmentShader, webGlContextAttributes]);
  useEffect2(() => {
    shaderMountRef.current?.setUniforms(uniforms);
  }, [uniforms]);
  useEffect2(() => {
    shaderMountRef.current?.setSpeed(speed);
  }, [speed]);
  useEffect2(() => {
    shaderMountRef.current?.setSeed(seed);
  }, [seed]);
  return /* @__PURE__ */ _jsx3("canvas", { ref: canvasRef, style });
};
AnimatedGradientBackground.displayName = "Animated Gradient Background";

export {
  GodRaysComp,
  AnimatedGradientBackground
};
