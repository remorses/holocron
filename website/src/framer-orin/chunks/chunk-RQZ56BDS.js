// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project dfa04aa1c5bdec07 "Jet - SaaS Template (copy)", do not edit manually */
// /:https://framerusercontent.com/modules/LZBhe3E2vEwdwNGrGIw7/3TUdBcS7IzAsyVTN4zJh/GodRays_Prod.js
import { jsx as _jsx, jsxs as _jsxs } from 'react/jsx-runtime'
import { ControlType, addPropertyControls, RenderTarget } from 'unframer'
import { useInView } from 'unframer'

// /:https://framerusercontent.com/modules/tinL9yUCRdYMMSkYrF00/5r5kMzvOdzXsRZCqA5qG/Bundle.js
import * as e from 'react'
import {
  forwardRef as t,
  useState as n,
  useRef as i,
  useEffect as r,
  memo as o,
} from 'react'
import { jsx as a } from 'react/jsx-runtime'
var __unframerNavigator = typeof window !== 'undefined' ? navigator : void 0
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true,
    })
  } else {
    obj[key] = value
  }
  return obj
}
var s = class {
  constructor(e2, t2, n2, i2, r2 = 0, o2 = 0, a2 = 2, s2 = 8294400) {
    _define_property(this, 'parentElement', void 0)
    _define_property(this, 'canvasElement', void 0)
    _define_property(this, 'gl', void 0)
    _define_property(this, 'program', null)
    _define_property(this, 'uniformLocations', {})
    _define_property(this, 'fragmentShader', void 0)
    _define_property(this, 'rafId', null)
    _define_property(this, 'lastRenderTime', 0)
    _define_property(this, 'totalFrameTime', 0)
    _define_property(this, 'speed', 0)
    _define_property(this, 'providedUniforms', void 0)
    _define_property(this, 'hasBeenDisposed', false)
    _define_property(this, 'resolutionChanged', true)
    _define_property(this, 'textures', /* @__PURE__ */ new Map())
    _define_property(this, 'minPixelRatio', void 0)
    _define_property(this, 'maxPixelCount', void 0)
    _define_property(
      this,
      'isSafari',
      (function () {
        const e3 = __unframerNavigator.userAgent.toLowerCase()
        return (
          e3.includes('safari') &&
          !e3.includes('chrome') &&
          !e3.includes('android')
        )
      })(),
    )
    _define_property(this, 'initProgram', () => {
      const e3 = (function (e4, t3, n3) {
        const i3 = c(e4, e4.VERTEX_SHADER, t3),
          r3 = c(e4, e4.FRAGMENT_SHADER, n3)
        if (!i3 || !r3) return null
        const o3 = e4.createProgram()
        if (!o3) return null
        if (
          (e4.attachShader(o3, i3),
          e4.attachShader(o3, r3),
          e4.linkProgram(o3),
          !e4.getProgramParameter(o3, e4.LINK_STATUS))
        )
          return (
            e4.deleteProgram(o3), e4.deleteShader(i3), e4.deleteShader(r3), null
          )
        return (
          e4.detachShader(o3, i3),
          e4.detachShader(o3, r3),
          e4.deleteShader(i3),
          e4.deleteShader(r3),
          o3
        )
      })(this.gl, l, this.fragmentShader)
      e3 && (this.program = e3)
    })
    _define_property(this, 'setupPositionAttribute', () => {
      const e3 = this.gl.getAttribLocation(this.program, 'a_position'),
        t3 = this.gl.createBuffer()
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, t3)
      this.gl.bufferData(
        this.gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),
        this.gl.STATIC_DRAW,
      ),
        this.gl.enableVertexAttribArray(e3),
        this.gl.vertexAttribPointer(e3, 2, this.gl.FLOAT, false, 0, 0)
    })
    _define_property(this, 'setupUniforms', () => {
      const e3 = {
        u_time: this.gl.getUniformLocation(this.program, 'u_time'),
        u_pixelRatio: this.gl.getUniformLocation(this.program, 'u_pixelRatio'),
        u_resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
      }
      Object.entries(this.providedUniforms).forEach(([t3, n3]) => {
        if (
          ((e3[t3] = this.gl.getUniformLocation(this.program, t3)),
          n3 instanceof HTMLImageElement)
        ) {
          const n4 = `${t3}_aspect_ratio`
          e3[n4] = this.gl.getUniformLocation(this.program, n4)
        }
      }),
        (this.uniformLocations = e3)
    })
    _define_property(this, 'renderScale', 1)
    _define_property(this, 'parentWidth', 0)
    _define_property(this, 'parentHeight', 0)
    _define_property(this, 'resizeObserver', null)
    _define_property(this, 'setupResizeObserver', () => {
      ;(this.resizeObserver = new ResizeObserver(([e4]) => {
        e4?.borderBoxSize[0] &&
          ((this.parentWidth = e4.borderBoxSize[0].inlineSize),
          (this.parentHeight = e4.borderBoxSize[0].blockSize)),
          this.handleResize()
      })),
        this.resizeObserver.observe(this.parentElement),
        visualViewport?.addEventListener(
          'resize',
          this.handleVisualViewportChange,
        )
      const e3 = this.parentElement.getBoundingClientRect()
      ;(this.parentWidth = e3.width),
        (this.parentHeight = e3.height),
        this.handleResize()
    })
    _define_property(this, 'resizeRafId', null)
    _define_property(this, 'handleVisualViewportChange', () => {
      null !== this.resizeRafId && cancelAnimationFrame(this.resizeRafId),
        (this.resizeRafId = requestAnimationFrame(() => {
          this.resizeRafId = requestAnimationFrame(() => {
            this.handleResize()
          })
        }))
    })
    _define_property(this, 'handleResize', () => {
      null !== this.resizeRafId && cancelAnimationFrame(this.resizeRafId)
      const e3 = visualViewport?.scale ?? 1,
        t3 = visualViewport
          ? visualViewport.width * visualViewport.scale
          : window.innerWidth,
        n3 = Math.round((1e4 * window.outerWidth) / t3) / 1e4,
        i3 = this.isSafari ? devicePixelRatio : devicePixelRatio / n3,
        r3 = Math.max(i3, this.minPixelRatio) * n3 * e3,
        o3 = this.parentWidth * r3,
        a3 = this.parentHeight * r3,
        s3 = Math.sqrt(this.maxPixelCount) / Math.sqrt(o3 * a3),
        l2 = r3 * Math.min(1, s3),
        c2 = Math.round(this.parentWidth * l2),
        u2 = Math.round(this.parentHeight * l2)
      ;(this.canvasElement.width === c2 &&
        this.canvasElement.height === u2 &&
        this.renderScale === l2) ||
        ((this.renderScale = l2),
        (this.canvasElement.width = c2),
        (this.canvasElement.height = u2),
        (this.resolutionChanged = true),
        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height),
        this.render(performance.now()))
    })
    _define_property(this, 'render', (e3) => {
      if (this.hasBeenDisposed) return
      if (null === this.program) return
      const t3 = e3 - this.lastRenderTime
      ;(this.lastRenderTime = e3),
        0 !== this.speed && (this.totalFrameTime += t3 * this.speed),
        this.gl.clear(this.gl.COLOR_BUFFER_BIT),
        this.gl.useProgram(this.program),
        this.gl.uniform1f(
          this.uniformLocations.u_time,
          1e-3 * this.totalFrameTime,
        ),
        this.resolutionChanged &&
          (this.gl.uniform2f(
            this.uniformLocations.u_resolution,
            this.gl.canvas.width,
            this.gl.canvas.height,
          ),
          this.gl.uniform1f(
            this.uniformLocations.u_pixelRatio,
            this.renderScale,
          ),
          (this.resolutionChanged = false)),
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6),
        0 !== this.speed ? this.requestRender() : (this.rafId = null)
    })
    _define_property(this, 'requestRender', () => {
      null !== this.rafId && cancelAnimationFrame(this.rafId),
        (this.rafId = requestAnimationFrame(this.render))
    })
    _define_property(this, 'setTextureUniform', (e3, t3) => {
      if (!t3.complete || 0 === t3.naturalWidth)
        throw new Error(
          `Paper Shaders: image for uniform ${e3} must be fully loaded`,
        )
      const n3 = this.textures.get(e3)
      n3 && this.gl.deleteTexture(n3)
      const i3 = this.gl.createTexture()
      this.gl.bindTexture(this.gl.TEXTURE_2D, i3),
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_WRAP_S,
          this.gl.REPEAT,
        ),
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_WRAP_T,
          this.gl.REPEAT,
        ),
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_MIN_FILTER,
          this.gl.LINEAR,
        ),
        this.gl.texParameteri(
          this.gl.TEXTURE_2D,
          this.gl.TEXTURE_MAG_FILTER,
          this.gl.LINEAR,
        ),
        this.gl.texImage2D(
          this.gl.TEXTURE_2D,
          0,
          this.gl.RGBA,
          this.gl.RGBA,
          this.gl.UNSIGNED_BYTE,
          t3,
        )
      if (this.gl.getError() !== this.gl.NO_ERROR || null === i3) return
      this.textures.set(e3, i3)
      const r3 = this.uniformLocations[e3]
      if (r3) {
        const n4 = this.textures.size - 1
        this.gl.useProgram(this.program),
          this.gl.activeTexture(this.gl.TEXTURE0 + n4),
          this.gl.bindTexture(this.gl.TEXTURE_2D, i3),
          this.gl.uniform1i(r3, n4)
        const o3 = `${e3}_aspect_ratio`,
          a3 = this.uniformLocations[o3]
        if (a3) {
          const e4 = t3.naturalWidth / t3.naturalHeight
          this.gl.uniform1f(a3, e4)
        }
      }
    })
    _define_property(this, 'setUniformValues', (e3) => {
      this.gl.useProgram(this.program),
        Object.entries(e3).forEach(([e4, t3]) => {
          const n3 = this.uniformLocations[e4]
          if (n3)
            if (t3 instanceof HTMLImageElement) this.setTextureUniform(e4, t3)
            else if (Array.isArray(t3)) {
              let e5 = null,
                i3 = null
              if (void 0 !== t3[0] && Array.isArray(t3[0])) {
                const n4 = t3[0].length
                if (!t3.every((e6) => e6.length === n4)) return
                ;(e5 = t3.flat()), (i3 = n4)
              } else (e5 = t3), (i3 = e5.length)
              switch (i3) {
                case 2:
                  this.gl.uniform2fv(n3, e5)
                  break
                case 3:
                  this.gl.uniform3fv(n3, e5)
                  break
                case 4:
                  this.gl.uniform4fv(n3, e5)
                  break
                case 9:
                  this.gl.uniformMatrix3fv(n3, false, e5)
                  break
                case 16:
                  this.gl.uniformMatrix4fv(n3, false, e5)
              }
            } else
              'number' == typeof t3
                ? this.gl.uniform1f(n3, t3)
                : 'boolean' == typeof t3 && this.gl.uniform1i(n3, t3 ? 1 : 0)
        })
    })
    _define_property(this, 'getCurrentFrameTime', () => this.totalFrameTime)
    _define_property(this, 'setFrame', (e3) => {
      ;(this.totalFrameTime = e3),
        (this.lastRenderTime = performance.now()),
        this.render(performance.now())
    })
    _define_property(this, 'setSpeed', (e3 = 1) => {
      ;(this.speed = e3),
        null === this.rafId &&
          0 !== e3 &&
          ((this.lastRenderTime = performance.now()),
          (this.rafId = requestAnimationFrame(this.render))),
        null !== this.rafId &&
          0 === e3 &&
          (cancelAnimationFrame(this.rafId), (this.rafId = null))
    })
    _define_property(this, 'setUniforms', (e3) => {
      ;(this.providedUniforms = { ...this.providedUniforms, ...e3 }),
        this.setUniformValues(e3),
        this.render(performance.now())
    })
    _define_property(this, 'dispose', () => {
      ;(this.hasBeenDisposed = true),
        null !== this.rafId &&
          (cancelAnimationFrame(this.rafId), (this.rafId = null)),
        this.gl &&
          this.program &&
          (this.textures.forEach((e3) => {
            this.gl.deleteTexture(e3)
          }),
          this.textures.clear(),
          this.gl.deleteProgram(this.program),
          (this.program = null),
          this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null),
          this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null),
          this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null),
          this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null),
          this.gl.getError()),
        this.resizeObserver &&
          (this.resizeObserver.disconnect(), (this.resizeObserver = null)),
        visualViewport?.removeEventListener(
          'resize',
          this.handleVisualViewportChange,
        ),
        (this.uniformLocations = {}),
        (this.parentElement.paperShaderMount = void 0)
    })
    if (!(e2 instanceof HTMLElement))
      throw new Error('Paper Shaders: parent element must be an HTMLElement')
    if (
      ((this.parentElement = e2),
      !document.querySelector('style[data-paper-shaders]'))
    ) {
      const e3 = document.createElement('style')
      ;(e3.innerHTML = u),
        e3.setAttribute('data-paper-shaders', ''),
        document.head.prepend(e3)
    }
    const l1 = document.createElement('canvas')
    ;(this.canvasElement = l1),
      this.parentElement.prepend(l1),
      (this.fragmentShader = t2),
      (this.providedUniforms = n2),
      (this.totalFrameTime = o2),
      (this.minPixelRatio = a2),
      (this.maxPixelCount = s2)
    const c1 = l1.getContext('webgl2', i2)
    if (!c1)
      throw new Error('Paper Shaders: WebGL is not supported in this browser')
    ;(this.gl = c1),
      this.initProgram(),
      this.setupPositionAttribute(),
      this.setupUniforms(),
      this.setUniformValues(this.providedUniforms),
      this.setupResizeObserver(),
      this.setSpeed(r2),
      this.parentElement.setAttribute('data-paper-shaders', ''),
      (this.parentElement.paperShaderMount = this)
  }
}
var l =
  '#version 300 es\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_objectHelperBox;\n\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxSize;\nout vec2 v_responsiveHelperBox;\nout vec2 v_responsiveBoxGivenSize;\n\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_patternHelperBox;\n\n// #define ADD_HELPERS\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize, vec2 maxBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n  // Sizing api for graphic objects with fixed ratio\n  // (currently supports only ratio = 1)\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize, maxBoxSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_objectHelperBox = uv;\n    v_objectHelperBox *= objectWorldScale;\n    v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);\n  #endif\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.\n  // Full-screen mode available with u_worldWidth = u_worldHeight = 0\n\n  v_responsiveBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize, maxBoxSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_responsiveHelperBox = uv;\n    v_responsiveHelperBox *= responsiveBoxScale;\n    v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for patterns\n  // (treating graphics as a image u_worldWidth x u_worldHeight size)\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize, maxBoxSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_patternHelperBox = uv;\n    v_patternHelperBox *= patternBoxScale;\n    v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);\n  #endif\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  v_patternUV += .5;\n\n  // ===================================================\n\n}'
function c(e2, t2, n2) {
  const i2 = e2.createShader(t2)
  return i2
    ? (e2.shaderSource(i2, n2),
      e2.compileShader(i2),
      e2.getShaderParameter(i2, e2.COMPILE_STATUS)
        ? i2
        : (e2.deleteShader(i2), null))
    : null
}
var u =
  '@layer paper-shaders {\n  :where([data-paper-shaders]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n    }\n  }\n}'
var h = {
  fit: 'contain',
  scale: 1,
  rotation: 0,
  offsetX: 0,
  offsetY: 0,
  originX: 0.5,
  originY: 0.5,
  worldWidth: 0,
  worldHeight: 0,
}
var f = { none: 0, contain: 1, cover: 2 }
var d = 5
var p = `#version 300 es
precision mediump float;

uniform float u_time;

uniform vec4 u_colorBack;
uniform vec4 u_colors[${d}];
uniform float u_colorsCount;

uniform float u_frequency;
uniform float u_spotty;
uniform float u_midSize;
uniform float u_midIntensity;
uniform float u_density;
uniform float u_blending;


in vec2 v_objectUV;
in vec2 v_responsiveUV;
in vec2 v_responsiveBoxGivenSize;
in vec2 v_patternUV;

out vec4 fragColor;


#define TWO_PI 6.28318530718
#define PI 3.14159265358979323846


float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}


vec2 rotate(vec2 uv, float th) {
  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;
}


float hash(float n) {
  return fract(sin(n * 43758.5453123) * 43758.5453123);
}

float valueNoise(vec2 uv) {
  vec2 i = floor(uv);
  vec2 f = fract(uv);

  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));

  vec2 u = f * f * (3.0 - 2.0 * f);

  float x1 = mix(a, b, u.x);
  float x2 = mix(c, d, u.x);
  return mix(x1, x2, u.y);
}

float raysShape(vec2 uv, float r, float freq, float density, float radius) {
  float a = atan(uv.y, uv.x);
  vec2 left = vec2(a * freq, r);
  vec2 right = vec2(mod(a, TWO_PI) * freq, r);
  float n_left = pow(valueNoise(left), density);
  float n_right = pow(valueNoise(right), density);
  float shape = mix(n_right, n_left, smoothstep(-.15, .15, uv.x));
  return shape;
}

void main() {
  vec2 shape_uv = v_objectUV;

  float t = .2 * u_time;

  float radius = length(shape_uv);
  float spots = 5. * abs(u_spotty);

  float density = 4. - 3. * clamp(u_density, 0., 1.);

  float delta = 1. - smoothstep(0., 1., radius);

  float middleShape = pow(u_midIntensity, .3) * smoothstep(abs(u_midSize), 0.02 * abs(u_midSize), 3.0 * radius);
  middleShape = pow(middleShape, 5.0);

  vec3 accumColor = vec3(0.0);
  float accumAlpha = 0.0;

  for (int i = 0; i < ${d}; i++) {
    if (i >= int(u_colorsCount)) break;

    vec2 rotatedUV = rotate(shape_uv, float(i) + 1.0);

    float r1 = radius * (1.0 + 0.4 * float(i)) - 3.0 * t;
    float r2 = 0.5 * radius * (1.0 + spots) - 2.0 * t;
    float f = mix(1.0, 3.0 + 0.5 * float(i), hash(float(i) + 10.0)) * u_frequency;

    float ray = raysShape(rotatedUV, r1, 5.0 * f, density, radius);
    ray *= raysShape(rotatedUV, r2, 4.0 * f, density, radius);
    ray += (1. + 4. * ray) * middleShape;
    ray = clamp(ray, 0.0, 1.0);

    float srcAlpha = u_colors[i].a * ray;
    vec3 srcColor = u_colors[i].rgb * srcAlpha;

    vec3 alphaBlendColor = accumColor + (1.0 - accumAlpha) * srcColor;
    float alphaBlendAlpha = accumAlpha + (1.0 - accumAlpha) * srcAlpha;

    vec3 addBlendColor = accumColor + srcColor;
    float addBlendAlpha = accumAlpha + srcAlpha;

    accumColor = mix(alphaBlendColor, addBlendColor, u_blending);
    accumAlpha = mix(alphaBlendAlpha, addBlendAlpha, u_blending);
  }

  vec3 bgColor = u_colorBack.rgb * u_colorBack.a;

  vec3 alphaBlendColor = accumColor + (1.0 - accumAlpha) * bgColor;
  float alphaBlendAlpha = accumAlpha + (1.0 - accumAlpha) * u_colorBack.a;

  vec3 addBlendColor = accumColor + bgColor;
  float addBlendAlpha = accumAlpha + u_colorBack.a;

  accumColor = mix(alphaBlendColor, addBlendColor, u_blending);
  accumAlpha = mix(alphaBlendAlpha, addBlendAlpha, u_blending);

  vec3 color = clamp(accumColor, 0.0, 1.0);
  float opacity = clamp(accumAlpha, 0.0, 1.0);


  
  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);


  fragColor = vec4(color, opacity);
}
`
function m(e2) {
  if (Array.isArray(e2))
    return 4 === e2.length ? e2 : 3 === e2.length ? [...e2, 1] : g
  if ('string' != typeof e2) return g
  let t2,
    n2,
    i2,
    r2 = 1
  if (e2.startsWith('#'))
    [t2, n2, i2, r2] = (function (e3) {
      3 === (e3 = e3.replace(/^#/, '')).length &&
        (e3 = e3
          .split('')
          .map((e4) => e4 + e4)
          .join(''))
      6 === e3.length && (e3 += 'ff')
      const t3 = parseInt(e3.slice(0, 2), 16) / 255,
        n3 = parseInt(e3.slice(2, 4), 16) / 255,
        i3 = parseInt(e3.slice(4, 6), 16) / 255,
        r3 = parseInt(e3.slice(6, 8), 16) / 255
      return [t3, n3, i3, r3]
    })(e2)
  else if (e2.startsWith('rgb'))
    [t2, n2, i2, r2] = (function (e3) {
      const t3 = e3.match(
        /^rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([0-9.]+))?\s*\)$/i,
      )
      return t3
        ? [
            parseInt(t3[1] ?? '0') / 255,
            parseInt(t3[2] ?? '0') / 255,
            parseInt(t3[3] ?? '0') / 255,
            void 0 === t3[4] ? 1 : parseFloat(t3[4]),
          ]
        : [0, 0, 0, 1]
    })(e2)
  else {
    if (!e2.startsWith('hsl')) return g
    ;[t2, n2, i2, r2] = (function (e3) {
      const [t3, n3, i3, r3] = e3,
        o2 = t3 / 360,
        a2 = n3 / 100,
        s2 = i3 / 100
      let l2, c2, u2
      if (0 === n3) l2 = c2 = u2 = s2
      else {
        const e4 = (e5, t5, n5) => (
            n5 < 0 && (n5 += 1),
            n5 > 1 && (n5 -= 1),
            n5 < 1 / 6
              ? e5 + 6 * (t5 - e5) * n5
              : n5 < 0.5
                ? t5
                : n5 < 2 / 3
                  ? e5 + (t5 - e5) * (2 / 3 - n5) * 6
                  : e5
          ),
          t4 = s2 < 0.5 ? s2 * (1 + a2) : s2 + a2 - s2 * a2,
          n4 = 2 * s2 - t4
        ;(l2 = e4(n4, t4, o2 + 1 / 3)),
          (c2 = e4(n4, t4, o2)),
          (u2 = e4(n4, t4, o2 - 1 / 3))
      }
      return [l2, c2, u2, r3]
    })(
      (function (e3) {
        const t3 = e3.match(
          /^hsla?\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(?:,\s*([0-9.]+))?\s*\)$/i,
        )
        return t3
          ? [
              parseInt(t3[1] ?? '0'),
              parseInt(t3[2] ?? '0'),
              parseInt(t3[3] ?? '0'),
              void 0 === t3[4] ? 1 : parseFloat(t3[4]),
            ]
          : [0, 0, 0, 1]
      })(e2),
    )
  }
  return [v(t2, 0, 1), v(n2, 0, 1), v(i2, 0, 1), v(r2, 0, 1)]
}
var v = (e2, t2, n2) => Math.min(Math.max(e2, t2), n2)
var g = [0, 0, 0, 1]
function x(t2) {
  const n2 = e.useRef(void 0),
    i2 = e.useCallback((e2) => {
      const n3 = t2.map((t3) => {
        if (null != t3) {
          if ('function' == typeof t3) {
            const n4 = t3,
              i3 = n4(e2)
            return 'function' == typeof i3
              ? i3
              : () => {
                  n4(null)
                }
          }
          return (
            (t3.current = e2),
            () => {
              t3.current = null
            }
          )
        }
      })
      return () => {
        n3.forEach((e3) => e3?.())
      }
    }, t2)
  return e.useMemo(
    () =>
      t2.every((e2) => null == e2)
        ? null
        : (e2) => {
            n2.current && (n2.current(), (n2.current = void 0)),
              null != e2 && (n2.current = i2(e2))
          },
    t2,
  )
}
async function _(e2) {
  const t2 = {},
    n2 = []
  return (
    Object.entries(e2).forEach(([e3, i2]) => {
      if ('string' == typeof i2) {
        if (
          !((e4) => {
            try {
              return e4.startsWith('/') || new URL(e4), true
            } catch {
              return false
            }
          })(i2)
        )
          return
        const r2 = new Promise((n3, r3) => {
          const o2 = new Image()
          ;((e4) => {
            try {
              return (
                !e4.startsWith('/') &&
                new URL(e4, window.location.origin).origin !==
                  window.location.origin
              )
            } catch {
              return false
            }
          })(i2) && (o2.crossOrigin = 'anonymous'),
            (o2.onload = () => {
              ;(t2[e3] = o2), n3()
            }),
            (o2.onerror = () => {
              r3()
            }),
            (o2.src = i2)
        })
        n2.push(r2)
      } else t2[e3] = i2
    }),
    await Promise.all(n2),
    t2
  )
}
var S = /* @__PURE__ */ t(function (
  {
    fragmentShader: e2,
    uniforms: t2,
    webGlContextAttributes: o2,
    speed: l2 = 0,
    frame: c2 = 0,
    minPixelRatio: u2,
    maxPixelCount: h2,
    ...f2
  },
  d2,
) {
  const [p2, m2] = n(false),
    v2 = i(null),
    g2 = i(null)
  return (
    r(
      () => (
        (async () => {
          const n2 = await _(t2)
          v2.current &&
            !g2.current &&
            ((g2.current = new s(v2.current, e2, n2, o2, l2, c2, u2, h2)),
            m2(true))
        })(),
        () => {
          g2.current?.dispose(), (g2.current = null)
        }
      ),
      [e2, o2],
    ),
    r(() => {
      ;(async () => {
        const e3 = await _(t2)
        g2.current?.setUniforms(e3)
      })()
    }, [t2, p2]),
    r(() => {
      g2.current?.setSpeed(l2)
    }, [l2, p2]),
    r(() => {
      g2.current?.setFrame(c2)
    }, [c2, p2]),
    a('div', { ref: x([v2, d2]), ...f2 })
  )
})
S.displayName = 'ShaderMount'
var B = {
  ...h,
  offsetX: -0.4,
  offsetY: -0.4,
  colorBack: 'hsla(215, 100%, 11%, 1)',
  colors: [
    'hsla(45, 100%, 70%, 1)',
    'hsla(10, 100%, 80%, 1)',
    'hsla(178, 100%, 83%, 1)',
  ],
  frequency: 6,
  spotty: 0.28,
  midIntensity: 1,
  midSize: 3,
  density: 0.3,
  blending: 0,
  speed: 1,
  frame: 0,
}
var b = /* @__PURE__ */ o(
  function ({
    speed: e2 = B.speed,
    frame: t2 = B.frame,
    colorBack: n2 = B.colorBack,
    colors: i2 = B.colors,
    frequency: r2 = B.frequency,
    spotty: o2 = B.spotty,
    midIntensity: s2 = B.midIntensity,
    midSize: l2 = B.midSize,
    density: c2 = B.density,
    blending: u2 = B.blending,
    fit: h2 = B.fit,
    scale: d2 = B.scale,
    rotation: v2 = B.rotation,
    originX: g2 = B.originX,
    originY: x2 = B.originY,
    offsetX: _2 = B.offsetX,
    offsetY: b2 = B.offsetY,
    worldWidth: R = B.worldWidth,
    worldHeight: y = B.worldHeight,
    ...z
  }) {
    const E = {
      u_colorBack: m(n2),
      u_colors: i2.map(m),
      u_colorsCount: i2.length,
      u_frequency: r2,
      u_spotty: o2,
      u_midIntensity: s2,
      u_midSize: l2,
      u_density: c2,
      u_blending: u2,
      u_fit: f[h2],
      u_scale: d2,
      u_rotation: v2,
      u_offsetX: _2,
      u_offsetY: b2,
      u_originX: g2,
      u_originY: x2,
      u_worldWidth: R,
      u_worldHeight: y,
    }
    return a(S, {
      ...z,
      speed: e2,
      frame: t2,
      fragmentShader: p,
      uniforms: E,
    })
  },
  function (e2, t2) {
    for (const n2 in e2)
      if ('colors' !== n2) {
        if (false === Object.is(e2[n2], t2[n2])) return false
      } else {
        const n3 = Array.isArray(e2.colors),
          i2 = Array.isArray(t2.colors)
        if (!n3 || !i2) {
          if (false === Object.is(e2.colors, t2.colors)) return false
          continue
        }
        if (e2.colors?.length !== t2.colors?.length) return false
        if (!e2.colors?.every((e3, n4) => e3 === t2.colors?.[n4])) return false
      }
    return true
  },
)

// /:https://framerusercontent.com/modules/LZBhe3E2vEwdwNGrGIw7/3TUdBcS7IzAsyVTN4zJh/GodRays_Prod.js
import { useRef as useRef2 } from 'react'
addPropertyControls(GodRaysComp, {
  preset: {
    type: ControlType.Enum,
    title: 'Preset',
    options: [
      'Time Travel',
      'Kinetic Field',
      'Highway',
      'Ocean',
      'Flowers',
      'Custom',
    ],
    defaultValue: 'Time Travel',
  },
  colorsMode: {
    type: ControlType.Enum,
    title: 'Color',
    options: ['Preset', 'Custom'],
    defaultValue: 'Preset',
    displaySegmentedControl: true,
  },
  noise: {
    type: ControlType.Object,
    optional: true,
    icon: 'effect',
    controls: {
      opacity: {
        type: ControlType.Number,
        defaultValue: 0.5,
        min: 0,
        max: 1,
        step: 0.01,
      },
      scale: {
        type: ControlType.Number,
        defaultValue: 1,
        min: 0.2,
        max: 2,
        step: 0.1,
      },
    },
  },
  colorBack: {
    type: ControlType.Color,
    title: 'Background',
    defaultValue: 'rgb(0,0,0)',
    hidden: (props) => props.colorsMode === 'Preset',
  },
  colors: {
    type: ControlType.Array,
    title: 'Ray Colors',
    control: { type: ControlType.Color },
    defaultValue: ['rgb(177, 177, 177)'],
    hidden: (props) => props.colorsMode === 'Preset',
  },
  frequency: {
    type: ControlType.Number,
    title: 'Frequency',
    defaultValue: 5,
    min: 0,
    max: 50,
    step: 0.5,
    hidden: (props) => props.preset !== 'Custom',
  },
  spotty: {
    type: ControlType.Number,
    title: 'Spotty',
    defaultValue: 0.5,
    min: 0,
    max: 10,
    step: 0.1,
    hidden: (props) => props.preset !== 'Custom',
  },
  center: {
    type: ControlType.Object,
    title: 'Center',
    controls: {
      size: {
        type: ControlType.Number,
        title: 'Size',
        defaultValue: 0.5,
        min: 0,
        max: 1,
        step: 0.1,
      },
      intensity: {
        type: ControlType.Number,
        title: 'Intensity',
        defaultValue: 0.5,
        min: 0,
        max: 1,
        step: 0.01,
      },
    },
    hidden: (props) => props.preset !== 'Custom',
  },
  density: {
    type: ControlType.Number,
    title: 'Density',
    defaultValue: 0.5,
    min: 0,
    max: 1,
    step: 0.01,
    hidden: (props) => props.preset !== 'Custom',
  },
  speed: {
    type: ControlType.Number,
    title: 'Speed',
    defaultValue: 1,
    min: 0,
    max: 10,
    step: 0.1,
    hidden: (props) => props.preset !== 'Custom',
  },
  offsetX: {
    type: ControlType.Number,
    title: 'Offset X',
    defaultValue: 0,
    min: -2,
    max: 2,
    step: 0.01,
    hidden: (props) => props.preset !== 'Custom',
  },
  offsetY: {
    type: ControlType.Number,
    title: 'Offset Y',
    defaultValue: 0,
    min: -2,
    max: 2,
    step: 0.01,
    hidden: (props) => props.preset !== 'Custom',
  },
  canvasPreview: {
    type: ControlType.Boolean,
    title: 'Preview',
    defaultValue: true,
    description:
      'More components at [Framer University](https://frameruni.link/cc).',
  },
})
GodRaysComp.defaultProps = {
  preset: 'Time Travel',
  colorsMode: 'Preset',
  colorBack: 'rgb(0,0,0)',
  colors: ['rgb(177, 177, 177)'],
  frequency: 5,
  spotty: 0.5,
  center: { size: 0.5, intensity: 0.5 },
  density: 0.5,
  speed: 1,
  offsetX: 0,
  offsetY: 0,
  canvasPreview: true,
}
function GodRaysComp(props) {
  const isOnFramerCanvas = RenderTarget.hasRestrictions()
  const ref = useRef2(null)
  const isInView = useInView(ref, { once: false })
  const activePreset = props.preset !== 'Custom' ? Presets[props.preset] : null
  const colorBack =
    props.colorsMode === 'Custom'
      ? parseFramerColor(props.colorBack)
      : activePreset
        ? parseFramerColor(activePreset.background)
        : parseFramerColor(props.colorBack)
  const colors =
    props.colorsMode === 'Custom'
      ? props.colors.map(parseFramerColor)
      : activePreset
        ? activePreset.colors.map(parseFramerColor)
        : props.colors.map(parseFramerColor)
  const finalSpeed =
    !props.canvasPreview && isOnFramerCanvas
      ? 0
      : activePreset
        ? activePreset.speed
        : props.speed
  const frequency = activePreset ? activePreset.frequency : props.frequency
  const spotty = activePreset ? activePreset.spotty : props.spotty
  const midSize = activePreset ? activePreset.center.size : props.center.size
  const midIntensity = activePreset
    ? activePreset.center.intensity
    : props.center.intensity
  const density = activePreset ? activePreset.density : props.density
  const speed = isInView ? finalSpeed : 0
  const offsetX = activePreset ? activePreset.offsetX : props.offsetX
  const offsetY = activePreset ? activePreset.offsetY : props.offsetY
  return /* @__PURE__ */ _jsxs('div', {
    ref,
    style: { width: '100%', height: '100%', position: 'relative' },
    children: [
      /* @__PURE__ */ _jsx(b, {
        style: { width: '100%', height: '100%' },
        colorBack,
        colors,
        frequency,
        spotty,
        midSize,
        midIntensity,
        density,
        blending: 1,
        speed,
        offsetX,
        offsetY,
      }),
      props.noise &&
        props.noise.opacity > 0 &&
        /* @__PURE__ */ _jsx('div', {
          style: {
            position: 'absolute',
            inset: 0,
            backgroundImage: `url("https://framerusercontent.com/images/g0QcWrxr87K0ufOxIUFBakwYA8.png")`,
            backgroundSize: props.noise.scale * 200,
            backgroundRepeat: 'repeat',
            opacity: props.noise.opacity / 2,
          },
        }),
    ],
  })
}
var Presets = {
  'Kinetic Field': {
    background: 'rgb(0,0,0)',
    colors: [
      'rgb(254, 128, 66)',
      'rgb(253, 251, 154)',
      'rgb(123, 76, 70)',
      'rgb(43, 21, 23)',
      'rgb(180, 43, 27)',
    ],
    frequency: 0,
    spotty: 5,
    center: { size: 1, intensity: 1 },
    density: 0.28,
    speed: 2,
    offsetX: 0,
    offsetY: 0,
  },
  'Time Travel': {
    background: 'rgb(0,0,0)',
    colors: [
      'rgb(17, 44, 113)',
      'rgb(187, 99, 255)',
      'rgb(86, 225, 233)',
      'rgb(91, 88, 235)',
      'rgb(10, 35, 83)',
    ],
    frequency: 0.5,
    spotty: 0,
    center: { size: 0.7, intensity: 0.33 },
    density: 0.74,
    speed: 2,
    offsetX: 0,
    offsetY: 0,
  },
  Highway: {
    background: 'rgb(0,0,0)',
    colors: ['rgb(94, 94, 94)', 'rgb(99, 250, 255)', 'rgb(0, 229, 255)'],
    frequency: 2,
    spotty: 0.2,
    center: { size: 0, intensity: 0.23 },
    density: 0,
    speed: 1.2,
    offsetX: 0,
    offsetY: -1.1,
  },
  Ocean: {
    background: 'rgb(0,0,0)',
    colors: ['rgb(62, 204, 248)', 'rgb(90, 118, 242)', 'rgb(41, 84, 231)'],
    frequency: 1.5,
    spotty: 0,
    center: { size: 0.7, intensity: 0.33 },
    density: 0.7,
    speed: 2,
    offsetX: 0,
    offsetY: -2,
  },
  Flowers: {
    background: 'rgb(0,0,0)',
    colors: ['rgb(255, 212, 100)', 'rgb(238, 34, 51)', 'rgb(95, 134, 250)'],
    frequency: 0.5,
    spotty: 1.9,
    center: { size: 0, intensity: 0.23 },
    density: 1,
    speed: 2,
    offsetX: -0.55,
    offsetY: 2,
  },
}
var parseFramerColor = (color) => {
  const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/)
  const rgbaMatch = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/)
  if (rgbaMatch) {
    const [_2, r2, g2, b2, a2] = rgbaMatch
    return `rgba(${r2}, ${g2}, ${b2}, ${a2})`
  } else if (rgbMatch) {
    const [_2, r2, g2, b2] = rgbMatch
    return `rgba(${r2}, ${g2}, ${b2}, 1)`
  }
  console.warn('Could not parse color:', color)
  return 'rgba(0, 0, 0, 1)'
}
GodRaysComp.displayName = 'God Rays'

// /:https://framerusercontent.com/modules/xx99X8dO7V1Egbc8GwnH/ghH1aHLmGZ0iE7qXDFVk/AnimatedLiquidBackground_Prod.js
import { jsx as _jsx3, jsxs as _jsxs2 } from 'react/jsx-runtime'
import {
  addPropertyControls as addPropertyControls2,
  ControlType as ControlType2,
  RenderTarget as RenderTarget3,
  useIsStaticRenderer,
} from 'unframer'
import {
  useEffect as useEffect2,
  useRef as useRef3,
  useMemo as useMemo3,
} from 'react'

// /:https://framerusercontent.com/modules/k76epLFsVsF4jlsF5pgg/vhK3G0ntf62fqS2tFDno/useColors.js
import { RenderTarget as RenderTarget2 } from 'unframer'
import { useEffect, useState, useMemo as useMemo2 } from 'react'
var cssVariableRegex =
  /var\s*\(\s*(--[\w-]+)(?:\s*,\s*((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*))?\s*\)/
function useColors(...colors) {
  const isCanvas = RenderTarget2.current() === RenderTarget2.canvas
  const isOptimizing = typeof window === 'undefined'
  const darkMode = useDarkMode()
  const [styleValues, setStyleValues] = useState(() =>
    extractStyleValues(colors.map(extractCSSVariableName)),
  )
  useEffect(() => {
    if (!isCanvas) return
    const div = document.body.querySelector('main > div')
    if (!div) return
    const observer = new MutationObserver(() => {
      setStyleValues(extractStyleValues(colors.map(extractCSSVariableName)))
    })
    observer.observe(div, { attributes: true, attributeFilter: ['style'] })
    return () => observer.disconnect()
  }, colors)
  const variableNames = useMemo2(
    () => colors.map(extractCSSVariableName),
    [colors],
  )
  if (isOptimizing) {
    return colors.map((color) => extractDefaultValue(color))
  }
  let values = []
  for (let i2 = 0; i2 < colors.length; i2++) {
    const color = colors[i2]
    if (typeof color !== 'string') {
      values.push(color)
      continue
    }
    const variableName = variableNames[i2]
    const colorValues = styleValues[variableName]
    if (variableName && colorValues) {
      values.push(
        darkMode
          ? colorValues.dark || colorValues.light || color
          : colorValues.light || color,
      )
    } else {
      values.push(color)
    }
  }
  return values
}
function extractStyleValues(variableNames) {
  const isCanvas = RenderTarget2.current() === RenderTarget2.canvas
  const result = {}
  let lightVars = {}
  let darkVars = {}
  if (isCanvas && typeof document !== 'undefined') {
    const div = document.body.querySelector('main > div')
    if (div) {
      const style = div.getAttribute('style')
      if (style) {
        const vars = parseVariables(style)
        lightVars = vars
        darkVars = vars
      }
    }
  } else {
    const { light, dark } = extractColorStyles()
    lightVars = parseVariables(light)
    darkVars = parseVariables(dark)
  }
  const allVarNames = /* @__PURE__ */ new Set([
    ...Object.keys(lightVars),
    ...Object.keys(darkVars),
  ])
  allVarNames.forEach((varName) => {
    result[varName] = {
      light: lightVars[varName] || '',
      dark: darkVars[varName] || '',
    }
  })
  return result
}
function extractColorStyles() {
  let lightSection = ''
  let darkSection = ''
  if (typeof document !== 'undefined') {
    const styles = document.head.querySelectorAll(
      'style[data-framer-css], style[data-framer-css-ssr], style[data-framer-css-ssr-minified]',
    )
    for (const style of styles) {
      const rules = style.sheet?.cssRules
      if (!rules) continue
      const styleRules = []
      for (const rule of rules) {
        if (rule instanceof CSSStyleRule) {
          styleRules.push([rule, false])
        } else if (rule instanceof CSSMediaRule) {
          if (rule.conditionText === '(prefers-color-scheme: dark)') {
            for (const subrule of rule.cssRules) {
              if (subrule instanceof CSSStyleRule) {
                styleRules.push([subrule, true])
              }
            }
          }
        }
      }
      for (const [rule, isDarkMedia] of styleRules) {
        const css = rule.cssText
        const hasVars = css.includes('--token-')
        if (!hasVars) continue
        const isDark = isDarkMedia
          ? rule.selectorText === 'body'
          : rule.selectorText === 'body[data-framer-theme="dark"]'
        const isLight = !isDarkMedia && rule.selectorText === 'body'
        if (!isDark && !isLight) continue
        if (isDark) {
          if (!darkSection) {
            darkSection = css
              .substring(css.indexOf('{') + 1, css.lastIndexOf('}'))
              .trim()
          }
        } else {
          if (!lightSection) {
            lightSection = css
              .substring(css.indexOf('{') + 1, css.lastIndexOf('}'))
              .trim()
          }
        }
        if (darkSection && lightSection) break
      }
      if (darkSection && lightSection) break
    }
  }
  return { light: lightSection, dark: darkSection }
}
function useDarkMode() {
  const isPreview =
    typeof window !== 'undefined' &&
    window.location.origin.endsWith('framercanvas.com')
  const [isDarkMode, setIsDarkMode] = useState(() => {
    if (typeof window === 'undefined') {
      return false
    } else if (isPreview && typeof document !== 'undefined') {
      return document.body.getAttribute('data-framer-theme') === 'dark'
    } else {
      return window.matchMedia('(prefers-color-scheme: dark)').matches
    }
  })
  useEffect(() => {
    if (isPreview) {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'data-framer-theme') {
            const theme = document.body.getAttribute('data-framer-theme')
            setIsDarkMode(theme === 'dark')
          }
        })
      })
      observer.observe(document.body, {
        attributes: true,
        attributeFilter: ['data-framer-theme'],
      })
      return () => observer.disconnect()
    } else {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
      const handleChange = (e2) => {
        setIsDarkMode(e2.matches)
      }
      if (mediaQuery.matches !== isDarkMode) {
        setIsDarkMode(mediaQuery.matches)
      }
      mediaQuery.addListener(handleChange)
      return () => mediaQuery.removeListener(handleChange)
    }
  }, [isPreview])
  return isDarkMode
}
function extractCSSVariableName(cssString) {
  if (!cssString || !cssString.startsWith('var(')) {
    return ''
  }
  const match = cssVariableRegex.exec(cssString)
  if (match) {
    const variableName = match[1]
    return variableName || ''
  }
  return ''
}
function parseVariables(section) {
  const vars = {}
  if (!section) return vars
  const declarations = section.split(';').filter(Boolean)
  declarations.forEach((declaration) => {
    const [name, value] = declaration.split(':').map((s2) => s2.trim())
    if (name && value) {
      vars[name] = value
    }
  })
  return vars
}
function extractDefaultValue(cssVar) {
  if (!cssVar || !cssVar.startsWith('var(')) {
    return cssVar
  }
  const content = cssVar.slice(4, -1)
  const parts = content.split(',')
  if (parts.length > 1) {
    return parts.slice(1).join(',').trim()
  }
  return ''
}

// /:https://framer.com/m/index-uMsj.js@PVl4bshKvCOZO36e3vK1
import { jsx as _jsx2 } from 'react/jsx-runtime'

// /:https://framerusercontent.com/modules/NLpw4UPElXpirDfZ8gK3/pnnblFdmCm84r7TGjG3U/shader_mount.js
function _define_property2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true,
    })
  } else {
    obj[key] = value
  }
  return obj
}
var ShaderMount = class {
  constructor(
    canvas,
    fragmentShader,
    uniforms = {},
    webGlContextAttributes,
    speed = 1,
    seed = 0,
  ) {
    _define_property2(this, 'canvas', void 0)
    _define_property2(this, 'gl', void 0)
    _define_property2(this, 'program', null)
    _define_property2(this, 'uniformLocations', {})
    _define_property2(this, 'fragmentShader', void 0)
    _define_property2(this, 'rafId', null)
    _define_property2(this, 'lastFrameTime', 0)
    _define_property2(this, 'totalAnimationTime', 0)
    _define_property2(this, 'speed', 1)
    _define_property2(this, 'providedUniforms', void 0)
    _define_property2(this, 'hasBeenDisposed', false)
    _define_property2(this, 'resolutionChanged', true)
    _define_property2(this, 'initWebGL', () => {
      const program = createProgram(
        this.gl,
        vertexShaderSource,
        this.fragmentShader,
      )
      if (!program) return
      this.program = program
      this.setupPositionAttribute()
      this.setupUniforms()
    })
    _define_property2(this, 'setupPositionAttribute', () => {
      const positionAttributeLocation = this.gl.getAttribLocation(
        this.program,
        'a_position',
      )
      const positionBuffer = this.gl.createBuffer()
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer)
      const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]
      this.gl.bufferData(
        this.gl.ARRAY_BUFFER,
        new Float32Array(positions),
        this.gl.STATIC_DRAW,
      )
      this.gl.enableVertexAttribArray(positionAttributeLocation)
      this.gl.vertexAttribPointer(
        positionAttributeLocation,
        2,
        this.gl.FLOAT,
        false,
        0,
        0,
      )
    })
    _define_property2(this, 'setupUniforms', () => {
      this.uniformLocations = {
        u_time: this.gl.getUniformLocation(this.program, 'u_time'),
        u_pixelRatio: this.gl.getUniformLocation(this.program, 'u_pixelRatio'),
        u_resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
        ...Object.fromEntries(
          Object.keys(this.providedUniforms).map((key) => [
            key,
            this.gl.getUniformLocation(this.program, key),
          ]),
        ),
      }
    })
    _define_property2(this, 'resizeObserver', null)
    _define_property2(this, 'setupResizeObserver', () => {
      this.resizeObserver = new ResizeObserver(() => this.handleResize())
      this.resizeObserver.observe(this.canvas)
      this.handleResize()
    })
    _define_property2(this, 'handleResize', () => {
      const pixelRatio = window.devicePixelRatio
      const newWidth = this.canvas.clientWidth * pixelRatio
      const newHeight = this.canvas.clientHeight * pixelRatio
      if (this.canvas.width !== newWidth || this.canvas.height !== newHeight) {
        this.canvas.width = newWidth
        this.canvas.height = newHeight
        this.resolutionChanged = true
        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height)
        this.render(performance.now())
      }
    })
    _define_property2(this, 'render', (currentTime) => {
      if (this.hasBeenDisposed) return
      const dt = currentTime - this.lastFrameTime
      this.lastFrameTime = currentTime
      if (this.speed !== 0) {
        this.totalAnimationTime += dt * this.speed
      }
      this.gl.clear(this.gl.COLOR_BUFFER_BIT)
      this.gl.useProgram(this.program)
      this.gl.uniform1f(
        this.uniformLocations.u_time,
        this.totalAnimationTime * 1e-3,
      )
      if (this.resolutionChanged) {
        this.gl.uniform2f(
          this.uniformLocations.u_resolution,
          this.gl.canvas.width,
          this.gl.canvas.height,
        )
        this.gl.uniform1f(
          this.uniformLocations.u_pixelRatio,
          window.devicePixelRatio,
        )
        this.resolutionChanged = false
      }
      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6)
      if (this.speed !== 0) {
        this.requestRender()
      } else {
        this.rafId = null
      }
    })
    _define_property2(this, 'requestRender', () => {
      if (this.rafId !== null) {
        cancelAnimationFrame(this.rafId)
      }
      this.rafId = requestAnimationFrame(this.render)
    })
    _define_property2(this, 'updateProvidedUniforms', () => {
      this.gl.useProgram(this.program)
      Object.entries(this.providedUniforms).forEach(([key, value]) => {
        const location = this.uniformLocations[key]
        if (location) {
          if (Array.isArray(value)) {
            switch (value.length) {
              case 2:
                this.gl.uniform2fv(location, value)
                break
              case 3:
                this.gl.uniform3fv(location, value)
                break
              case 4:
                this.gl.uniform4fv(location, value)
                break
              default:
                if (value.length === 9) {
                  this.gl.uniformMatrix3fv(location, false, value)
                } else if (value.length === 16) {
                  this.gl.uniformMatrix4fv(location, false, value)
                } else {
                  console.warn(
                    `Unsupported uniform array length: ${value.length}`,
                  )
                }
            }
          } else if (typeof value === 'number') {
            this.gl.uniform1f(location, value)
          } else if (typeof value === 'boolean') {
            this.gl.uniform1i(location, value ? 1 : 0)
          } else {
            console.warn(`Unsupported uniform type for ${key}: ${typeof value}`)
          }
        }
      })
    })
    _define_property2(this, 'setSeed', (newSeed) => {
      const oneFrameAt120Fps = 1e3 / 120
      this.totalAnimationTime = newSeed * oneFrameAt120Fps
      this.lastFrameTime = performance.now()
      this.render(performance.now())
    })
    _define_property2(this, 'setSpeed', (newSpeed = 1) => {
      this.speed = newSpeed
      if (this.rafId === null && newSpeed !== 0) {
        this.lastFrameTime = performance.now()
        this.rafId = requestAnimationFrame(this.render)
      }
      if (this.rafId !== null && newSpeed === 0) {
        cancelAnimationFrame(this.rafId)
        this.rafId = null
      }
    })
    _define_property2(this, 'setUniforms', (newUniforms) => {
      this.providedUniforms = { ...this.providedUniforms, ...newUniforms }
      this.updateProvidedUniforms()
      this.render(performance.now())
    })
    _define_property2(this, 'dispose', () => {
      this.hasBeenDisposed = true
      if (this.rafId !== null) {
        cancelAnimationFrame(this.rafId)
        this.rafId = null
      }
      if (this.gl && this.program) {
        this.gl.deleteProgram(this.program)
        this.program = null
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null)
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null)
        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null)
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null)
        this.gl.getError()
      }
      if (this.resizeObserver) {
        this.resizeObserver.disconnect()
        this.resizeObserver = null
      }
      this.uniformLocations = {}
    })
    this.canvas = canvas
    this.fragmentShader = fragmentShader
    this.providedUniforms = uniforms
    this.totalAnimationTime = seed
    const gl = canvas.getContext('webgl2', webGlContextAttributes)
    if (!gl) {
      throw new Error('WebGL not supported')
    }
    this.gl = gl
    this.initWebGL()
    this.setupResizeObserver()
    this.setSpeed(speed)
    this.canvas.setAttribute('data-paper-shaders', 'true')
  }
}
var vertexShaderSource = `#version 300 es
layout(location = 0) in vec4 a_position;

void main() {
  gl_Position = a_position;
}
`
function createShader(gl, type, source) {
  const shader = gl.createShader(type)
  if (!shader) return null
  gl.shaderSource(shader, source)
  gl.compileShader(shader)
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(
      'An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader),
    )
    gl.deleteShader(shader)
    return null
  }
  return shader
}
function createProgram(gl, vertexShaderSource2, fragmentShaderSource) {
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource2)
  const fragmentShader = createShader(
    gl,
    gl.FRAGMENT_SHADER,
    fragmentShaderSource,
  )
  if (!vertexShader || !fragmentShader) return null
  const program = gl.createProgram()
  if (!program) return null
  gl.attachShader(program, vertexShader)
  gl.attachShader(program, fragmentShader)
  gl.linkProgram(program)
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(
      'Unable to initialize the shader program: ' +
        gl.getProgramInfoLog(program),
    )
    gl.deleteProgram(program)
    gl.deleteShader(vertexShader)
    gl.deleteShader(fragmentShader)
    return null
  }
  gl.detachShader(program, vertexShader)
  gl.detachShader(program, fragmentShader)
  gl.deleteShader(vertexShader)
  gl.deleteShader(fragmentShader)
  return program
}

// /:https://framerusercontent.com/modules/zIDOp1iaNFIXSAIx7ljo/VX06XYWdAlD95B9usTKm/warp.js
var PatternShapes = { Checks: 0, Stripes: 1, Edge: 2 }
var warpFragmentShader = `#version 300 es
precision highp float;

uniform float u_time;
uniform float u_pixelRatio;
uniform vec2 u_resolution;

uniform float u_scale;
uniform float u_rotation;
uniform vec4 u_color1;
uniform vec4 u_color2;
uniform vec4 u_color3;
uniform float u_proportion;
uniform float u_softness;
uniform float u_shape;
uniform float u_shapeScale;
uniform float u_distortion;
uniform float u_swirl;
uniform float u_swirlIterations;


out vec4 fragColor;

#define TWO_PI 6.28318530718
#define PI 3.14159265358979323846

vec2 rotate(vec2 uv, float th) {
  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;
}

float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}
float noise(vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);
  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));

  // Smoothstep for interpolation
  vec2 u = f * f * (3.0 - 2.0 * f);

  // Do the interpolation as two nested mix operations
  // If you try to do this in one big operation, there's enough precision loss to be off by 1px at cell boundaries
  float x1 = mix(a, b, u.x);
  float x2 = mix(c, d, u.x);
  return mix(x1, x2, u.y);

}

vec4 blend_colors(vec4 c1, vec4 c2, vec4 c3, float mixer, float edgesWidth, float edge_blur) {
    vec3 color1 = c1.rgb * c1.a;
    vec3 color2 = c2.rgb * c2.a;
    vec3 color3 = c3.rgb * c3.a;

    float r1 = smoothstep(.0 + .35 * edgesWidth, .7 - .35 * edgesWidth + .5 * edge_blur, mixer);
    float r2 = smoothstep(.3 + .35 * edgesWidth, 1. - .35 * edgesWidth + edge_blur, mixer);

    vec3 blended_color_2 = mix(color1, color2, r1);
    float blended_opacity_2 = mix(c1.a, c2.a, r1);

    vec3 c = mix(blended_color_2, color3, r2);
    float o = mix(blended_opacity_2, c3.a, r2);
    return vec4(c, o);
}

void main() {
    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
    vec2 uv_original = uv;

    float t = .5 * u_time;

    float noise_scale = .0005 + .006 * u_scale;

    uv -= .5;
    uv *= (noise_scale * u_resolution);
    uv = rotate(uv, u_rotation * .5 * PI);
    uv /= u_pixelRatio;
    uv += .5;

    float n1 = noise(uv * 1. + t);
    float n2 = noise(uv * 2. - t);
    float angle = n1 * TWO_PI;
    uv.x += 4. * u_distortion * n2 * cos(angle);
    uv.y += 4. * u_distortion * n2 * sin(angle);

    float iterations_number = ceil(clamp(u_swirlIterations, 1., 30.));
    for (float i = 1.; i <= iterations_number; i++) {
        uv.x += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1.5 * uv.y);
        uv.y += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1. * uv.x);
    }

    float proportion = clamp(u_proportion, 0., 1.);

    float shape = 0.;
    float mixer = 0.;
    if (u_shape < .5) {
      vec2 checks_shape_uv = uv * (.5 + 3.5 * u_shapeScale);
      shape = .5 + .5 * sin(checks_shape_uv.x) * cos(checks_shape_uv.y);
      mixer = shape + .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);
    } else if (u_shape < 1.5) {
      vec2 stripes_shape_uv = uv * (.25 + 3. * u_shapeScale);
      float f = fract(stripes_shape_uv.y);
      shape = smoothstep(.0, .55, f) * smoothstep(1., .45, f);
      mixer = shape + .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);
    } else {
      float sh = 1. - uv.y;
      sh -= .5;
      sh /= (noise_scale * u_resolution.y);
      sh += .5;
      float shape_scaling = .2 * (1. - u_shapeScale);
      shape = smoothstep(.45 - shape_scaling, .55 + shape_scaling, sh + .3 * (proportion - .5));
      mixer = shape;
    }

    vec4 color_mix = blend_colors(u_color1, u_color2, u_color3, mixer, 1. - clamp(u_softness, 0., 1.), .01 + .01 * u_scale);

    fragColor = vec4(color_mix.rgb, color_mix.a);
}
`

// /:https://framerusercontent.com/modules/r591zLdRh7n2CKaaHRG7/PCYxubr6wk68eTxKLhEH/get_shader_color_from_string.js
function getShaderColorFromString(colorString, fallback = [0, 0, 0, 1]) {
  if (Array.isArray(colorString)) {
    if (colorString.length === 4) return colorString
    if (colorString.length === 3) return [...colorString, 1]
    return getShaderColorFromString(fallback)
  }
  if (typeof colorString !== 'string') {
    return getShaderColorFromString(fallback)
  }
  let r2,
    g2,
    b2,
    a2 = 1
  if (colorString.startsWith('#')) {
    ;[r2, g2, b2, a2] = hexToRgba(colorString)
  } else if (colorString.startsWith('rgb')) {
    ;[r2, g2, b2, a2] = parseRgba(colorString)
  } else if (colorString.startsWith('hsl')) {
    ;[r2, g2, b2, a2] = hslaToRgba(parseHsla(colorString))
  } else {
    console.error('Unsupported color format', colorString)
    return getShaderColorFromString(fallback)
  }
  return [clamp(r2, 0, 1), clamp(g2, 0, 1), clamp(b2, 0, 1), clamp(a2, 0, 1)]
}
function hexToRgba(hex) {
  hex = hex.replace(/^#/, '')
  if (hex.length === 3) {
    hex = hex
      .split('')
      .map((char) => char + char)
      .join('')
  }
  if (hex.length === 6) {
    hex = hex + 'ff'
  }
  const r2 = parseInt(hex.slice(0, 2), 16) / 255
  const g2 = parseInt(hex.slice(2, 4), 16) / 255
  const b2 = parseInt(hex.slice(4, 6), 16) / 255
  const a2 = parseInt(hex.slice(6, 8), 16) / 255
  return [r2, g2, b2, a2]
}
function parseRgba(rgba) {
  const match = rgba.match(
    /^rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([0-9.]+))?\s*\)$/i,
  )
  if (!match) return [0, 0, 0, 1]
  return [
    parseInt(match[1] ?? '0') / 255,
    parseInt(match[2] ?? '0') / 255,
    parseInt(match[3] ?? '0') / 255,
    match[4] === void 0 ? 1 : parseFloat(match[4]),
  ]
}
function parseHsla(hsla) {
  const match = hsla.match(
    /^hsla?\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(?:,\s*([0-9.]+))?\s*\)$/i,
  )
  if (!match) return [0, 0, 0, 1]
  return [
    parseInt(match[1] ?? '0'),
    parseInt(match[2] ?? '0'),
    parseInt(match[3] ?? '0'),
    match[4] === void 0 ? 1 : parseFloat(match[4]),
  ]
}
function hslaToRgba(hsla) {
  const [h2, s2, l2, a2] = hsla
  const hDecimal = h2 / 360
  const sDecimal = s2 / 100
  const lDecimal = l2 / 100
  let r2, g2, b2
  if (s2 === 0) {
    r2 = g2 = b2 = lDecimal
  } else {
    const hue2rgb = (p22, q2, t2) => {
      if (t2 < 0) t2 += 1
      if (t2 > 1) t2 -= 1
      if (t2 < 1 / 6) return p22 + (q2 - p22) * 6 * t2
      if (t2 < 1 / 2) return q2
      if (t2 < 2 / 3) return p22 + (q2 - p22) * (2 / 3 - t2) * 6
      return p22
    }
    const q =
      lDecimal < 0.5
        ? lDecimal * (1 + sDecimal)
        : lDecimal + sDecimal - lDecimal * sDecimal
    const p2 = 2 * lDecimal - q
    r2 = hue2rgb(p2, q, hDecimal + 1 / 3)
    g2 = hue2rgb(p2, q, hDecimal)
    b2 = hue2rgb(p2, q, hDecimal - 1 / 3)
  }
  return [r2, g2, b2, a2]
}
var clamp = (n2, min, max) => Math.min(Math.max(n2, min), max)

// /:https://framerusercontent.com/modules/xx99X8dO7V1Egbc8GwnH/ghH1aHLmGZ0iE7qXDFVk/AnimatedLiquidBackground_Prod.js
import { cubicBezier, useInView as useInView2 } from 'unframer'
var speedEase = cubicBezier(0.65, 0, 0.88, 0.77)
var templates = {
  Prism: {
    color1: '#050505',
    color2: '#66B3FF',
    color3: '#FFFFFF',
    rotation: -50,
    proportion: 1,
    scale: 0.01,
    speed: 30,
    distortion: 0,
    swirl: 50,
    swirlIterations: 16,
    softness: 47,
    offset: -299,
    shape: 'Checks',
    shapeSize: 45,
  },
  Lava: {
    color1: '#FF9F21',
    color2: '#FF0303',
    color3: '#000000',
    rotation: 114,
    proportion: 100,
    scale: 0.52,
    speed: 30,
    distortion: 7,
    swirl: 18,
    swirlIterations: 20,
    softness: 100,
    offset: 717,
    shape: 'Edge',
    shapeSize: 12,
  },
  Plasma: {
    color1: '#B566FF',
    color2: '#000000',
    color3: '#000000',
    rotation: 0,
    proportion: 63,
    scale: 0.75,
    speed: 30,
    distortion: 5,
    swirl: 61,
    swirlIterations: 5,
    softness: 100,
    offset: -168,
    shape: 'Checks',
    shapeSize: 28,
  },
  Pulse: {
    color1: '#66FF85',
    color2: '#000000',
    color3: '#000000',
    rotation: -167,
    proportion: 92,
    scale: 0,
    speed: 20,
    distortion: 54,
    swirl: 75,
    swirlIterations: 3,
    softness: 28,
    offset: -813,
    shape: 'Checks',
    shapeSize: 79,
  },
  Vortex: {
    color1: '#000000',
    color2: '#FFFFFF',
    color3: '#000000',
    rotation: 50,
    proportion: 41,
    scale: 0.4,
    speed: 20,
    distortion: 0,
    swirl: 100,
    swirlIterations: 3,
    softness: 5,
    offset: -744,
    shape: 'Stripes',
    shapeSize: 80,
  },
  Mist: {
    color1: '#050505',
    color2: '#FF66B8',
    color3: '#050505',
    rotation: 0,
    proportion: 33,
    scale: 0.48,
    speed: 39,
    distortion: 4,
    swirl: 65,
    swirlIterations: 5,
    softness: 100,
    offset: -235,
    shape: 'Edge',
    shapeSize: 48,
  },
}
function AnimatedGradientBackground(props) {
  const isStaticRenderer = useIsStaticRenderer()
  const isCanvas = RenderTarget3.current() === RenderTarget3.canvas
  const useCustomColors =
    props.preset === 'custom' || props.colorMode === 'custom'
  const values =
    props.preset === 'custom'
      ? props
      : templates[props.preset] || Object.values(templates)[0]
  const [color1, color2, color3] = useColors(
    props.color1,
    props.color2,
    props.color3,
  )
  const ref = useRef3(null)
  const isInView = useInView2(ref, { once: false, amount: 0.1 })
  const currentSpeed = useMemo3(() => {
    if (isCanvas && props.preview) return speedEase(props.speed / 100) * 5
    if (!isStaticRenderer && isInView) return speedEase(props.speed / 100) * 5
    return 0
  }, [isInView, isStaticRenderer, props.speed, props.preview, isCanvas])
  return /* @__PURE__ */ _jsxs2('div', {
    ref,
    style: {
      borderRadius: props.radius,
      overflow: 'hidden',
      position: 'relative',
      ...props.style,
    },
    children: [
      /* @__PURE__ */ _jsx3(Warp, {
        color1: useCustomColors ? color1 : values.color1,
        color2: useCustomColors ? color2 : values.color2,
        color3: useCustomColors ? color3 : values.color3,
        scale: values.scale,
        proportion: values.proportion / 100,
        distortion: values.distortion / 50,
        swirl: values.swirl / 100,
        swirlIterations: values.swirl === 0 ? 0 : values.swirlIterations,
        rotation: (values.rotation * Math.PI) / 180,
        speed: currentSpeed,
        seed: values.offset * 10,
        shape: PatternShapes[values.shape],
        shapeScale: values.shapeSize / 100,
        softness: values.softness / 100,
        style: props.style,
      }),
      props.noise &&
        props.noise.opacity > 0 &&
        /* @__PURE__ */ _jsx3('div', {
          style: {
            position: 'absolute',
            inset: 0,
            backgroundImage: `url("https://framerusercontent.com/images/g0QcWrxr87K0ufOxIUFBakwYA8.png")`,
            backgroundSize: props.noise.scale * 200,
            backgroundRepeat: 'repeat',
            opacity: props.noise.opacity / 2,
          },
        }),
    ],
  })
}
addPropertyControls2(AnimatedGradientBackground, {
  preset: {
    type: ControlType2.Enum,
    defaultValue: Object.keys(templates)[0],
    options: [...Object.keys(templates), 'custom'],
    optionTitles: [...Object.keys(templates), 'Custom'],
  },
  preview: { type: ControlType2.Boolean, defaultValue: false },
  colorMode: {
    type: ControlType2.Enum,
    defaultValue: 'preset',
    options: ['preset', 'custom'],
    optionTitles: ['Preset', 'Custom'],
    displaySegmentedControl: true,
    title: 'Colors',
    hidden: (props) => props.preset === 'custom',
  },
  color1: {
    type: ControlType2.Color,
    defaultValue: '#262626',
    hidden: (props) =>
      props.preset !== 'custom' && props.colorMode === 'preset',
  },
  color2: {
    type: ControlType2.Color,
    defaultValue: '#75c1f0',
    hidden: (props) =>
      props.preset !== 'custom' && props.colorMode === 'preset',
  },
  color3: {
    type: ControlType2.Color,
    defaultValue: '#ffffff',
    hidden: (props) =>
      props.preset !== 'custom' && props.colorMode === 'preset',
  },
  noise: {
    type: ControlType2.Object,
    optional: true,
    icon: 'effect',
    controls: {
      opacity: {
        type: ControlType2.Number,
        defaultValue: 0.5,
        min: 0,
        max: 1,
        step: 0.01,
      },
      scale: {
        type: ControlType2.Number,
        defaultValue: 1,
        min: 0.2,
        max: 2,
        step: 0.1,
      },
    },
  },
  rotation: {
    type: ControlType2.Number,
    defaultValue: 0,
    min: -360,
    max: 360,
    step: 1,
    unit: '\xB0',
    hidden: (props) => props.preset !== 'custom',
  },
  proportion: {
    type: ControlType2.Number,
    defaultValue: 35,
    min: 0,
    max: 100,
    step: 1,
    hidden: (props) => props.preset !== 'custom',
  },
  scale: {
    type: ControlType2.Number,
    defaultValue: 1,
    min: 0,
    max: 10,
    step: 0.01,
    hidden: (props) => props.preset !== 'custom',
  },
  speed: {
    type: ControlType2.Number,
    defaultValue: 25,
    step: 1,
    min: 0,
    max: 100,
  },
  distortion: {
    type: ControlType2.Number,
    defaultValue: 12,
    min: 0,
    max: 100,
    step: 1,
    hidden: (props) => props.preset !== 'custom',
  },
  swirl: {
    type: ControlType2.Number,
    defaultValue: 80,
    min: 0,
    max: 100,
    step: 1,
    hidden: (props) => props.preset !== 'custom',
  },
  swirlIterations: {
    type: ControlType2.Number,
    defaultValue: 10,
    min: 0,
    max: 20,
    step: 1,
    title: 'Iterations',
    hidden: (props) => props.swirl === 0 || props.preset !== 'custom',
  },
  softness: {
    type: ControlType2.Number,
    defaultValue: 100,
    min: 0,
    max: 100,
    step: 1,
    hidden: (props) => props.preset !== 'custom',
  },
  offset: {
    type: ControlType2.Number,
    defaultValue: 0,
    min: -1e3,
    max: 1e3,
    step: 1,
    hidden: (props) => props.preset !== 'custom',
  },
  shape: {
    type: ControlType2.Enum,
    defaultValue: 'Checks',
    options: Object.keys(PatternShapes),
    hidden: (props) => props.preset !== 'custom',
  },
  shapeSize: {
    type: ControlType2.Number,
    defaultValue: 10,
    min: 0,
    max: 100,
    step: 1,
    hidden: (props) => props.preset !== 'custom',
  },
  radius: { type: ControlType2.BorderRadius, defaultValue: '0px' },
})
var defaultPreset = {
  name: 'Default',
  params: {
    scale: 1,
    rotation: 0,
    speed: 20,
    seed: 0,
    color1: 'hsla(0, 0%, 15%, 1)',
    color2: 'hsla(203, 80%, 70%, 1)',
    color3: 'hsla(0, 0%, 100%, 1)',
    proportion: 0.35,
    softness: 1,
    distortion: 0.25,
    swirl: 0.8,
    swirlIterations: 10,
    shapeScale: 0.1,
    shape: PatternShapes.Checks,
  },
}
var Warp = (props) => {
  const uniforms = useMemo3(() => {
    return {
      u_scale: props.scale ?? defaultPreset.params.scale,
      u_rotation: props.rotation ?? defaultPreset.params.rotation,
      u_color1: getShaderColorFromString(
        props.color1,
        defaultPreset.params.color1,
      ),
      u_color2: getShaderColorFromString(
        props.color2,
        defaultPreset.params.color2,
      ),
      u_color3: getShaderColorFromString(
        props.color3,
        defaultPreset.params.color2,
      ),
      u_proportion: props.proportion ?? defaultPreset.params.proportion,
      u_softness: props.softness ?? defaultPreset.params.softness,
      u_distortion: props.distortion ?? defaultPreset.params.distortion,
      u_swirl: props.swirl ?? defaultPreset.params.swirl,
      u_swirlIterations:
        props.swirlIterations ?? defaultPreset.params.swirlIterations,
      u_shapeScale: props.shapeScale ?? defaultPreset.params.shapeScale,
      u_shape: props.shape ?? defaultPreset.params.shape,
    }
  }, [
    props.scale,
    props.rotation,
    props.color1,
    props.color2,
    props.color3,
    props.proportion,
    props.softness,
    props.distortion,
    props.swirl,
    props.swirlIterations,
    props.shapeScale,
    props.shape,
    props.speed,
  ])
  return /* @__PURE__ */ _jsx3(ShaderMount2, {
    ...props,
    fragmentShader: warpFragmentShader,
    uniforms,
  })
}
var ShaderMount2 = ({
  ref,
  fragmentShader,
  style,
  uniforms = {},
  webGlContextAttributes,
  speed = 1,
  seed = 0,
}) => {
  const canvasRef = ref ?? useRef3(null)
  const shaderMountRef = useRef3(null)
  useEffect2(() => {
    if (canvasRef.current) {
      shaderMountRef.current = new ShaderMount(
        canvasRef.current,
        fragmentShader,
        uniforms,
        webGlContextAttributes,
        speed,
        seed,
      )
    }
    return () => {
      shaderMountRef.current?.dispose()
    }
  }, [fragmentShader, webGlContextAttributes])
  useEffect2(() => {
    shaderMountRef.current?.setUniforms(uniforms)
  }, [uniforms])
  useEffect2(() => {
    shaderMountRef.current?.setSpeed(speed)
  }, [speed])
  useEffect2(() => {
    shaderMountRef.current?.setSeed(seed)
  }, [seed])
  return /* @__PURE__ */ _jsx3('canvas', { ref: canvasRef, style })
}
AnimatedGradientBackground.displayName = 'Animated Gradient Background'

export { GodRaysComp, AnimatedGradientBackground }
